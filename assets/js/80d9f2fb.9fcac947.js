"use strict";(self.webpackChunk_CapybaraIO_docs=self.webpackChunk_CapybaraIO_docs||[]).push([[2340],{3905:(e,t,n)=>{n.d(t,{Zo:()=>p,kt:()=>m});var a=n(67294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function s(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function o(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},i=Object.keys(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var l=a.createContext({}),c=function(e){var t=a.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):s(s({},t),e)),n},p=function(e){var t=c(e.components);return a.createElement(l.Provider,{value:t},e.children)},d="mdxType",u={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},h=a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,i=e.originalType,l=e.parentName,p=o(e,["components","mdxType","originalType","parentName"]),d=c(n),h=r,m=d["".concat(l,".").concat(h)]||d[h]||u[h]||i;return n?a.createElement(m,s(s({ref:t},p),{},{components:n})):a.createElement(m,s({ref:t},p))}));function m(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var i=n.length,s=new Array(i);s[0]=h;var o={};for(var l in t)hasOwnProperty.call(t,l)&&(o[l]=t[l]);o.originalType=e,o[d]="string"==typeof e?e:r,s[1]=o;for(var c=2;c<i;c++)s[c]=n[c];return a.createElement.apply(null,s)}return a.createElement.apply(null,n)}h.displayName="MDXCreateElement"},30174:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>s,default:()=>u,frontMatter:()=>i,metadata:()=>o,toc:()=>c});var a=n(87462),r=(n(67294),n(3905));const i={id:"clarity-billboard",title:"Billboard"},s=void 0,o={unversionedId:"tutorials/clarity-billboard",id:"tutorials/clarity-billboard",title:"Billboard",description:"This tutorial demonstrates how to transfer STX tokens and handle errors in Clarity by building a simple on-chain message",source:"@site/docs/tutorials/clarity-billboard.md",sourceDirName:"tutorials",slug:"/tutorials/clarity-billboard",permalink:"/doc/tutorials/clarity-billboard",draft:!1,editUrl:"https://github.com/CapybaraIO/doc/tree/main/docs/tutorials/clarity-billboard.md",tags:[],version:"current",lastUpdatedAt:1703206175,formattedLastUpdatedAt:"Dec 22, 2023",frontMatter:{id:"clarity-billboard",title:"Billboard"},sidebar:"tutorials",previous:{title:"Counter",permalink:"/doc/tutorials/clarity-counter"},next:{title:"Non-fungible tokens",permalink:"/doc/tutorials/clarity-nft"}},l={},c=[{value:"Prerequisites",id:"prerequisites",level:2},{value:"Step 1: Set up the project",id:"step-1-set-up-the-project",level:2},{value:"Step 2: Create message storage",id:"step-2-create-message-storage",level:2},{value:"Step 3: Define set message function",id:"step-3-define-set-message-function",level:2},{value:"Step 4: Transfer STX to set message",id:"step-4-transfer-stx-to-set-message",level:2},{value:"Step 5: Write a contract test",id:"step-5-write-a-contract-test",level:2}],p={toc:c},d="wrapper";function u(e){let{components:t,...n}=e;return(0,r.kt)(d,(0,a.Z)({},p,n,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"This tutorial demonstrates how to transfer STX tokens and handle errors in Clarity by building a simple on-chain message\nstore. Additionally, this tutorial provides a simple overview of testing a smart contract. This tutorial builds on\nconcepts introduced in the ","[counter tutorial][]",", and uses ","[Clarinet][]"," to develop and test the smart contract."),(0,r.kt)("p",null,"In this tutorial you will:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Set up a development environment with Clarinet"),(0,r.kt)("li",{parentName:"ul"},"Define codes for error handling"),(0,r.kt)("li",{parentName:"ul"},"Add a data storage variable with functions to get and set the variable"),(0,r.kt)("li",{parentName:"ul"},"Add a STX transfer function within the variable setter"),(0,r.kt)("li",{parentName:"ul"},"Develop a unit test to verify the contract works as expected")),(0,r.kt)("p",null,"The ","[final code for this tutorial][]"," is available in the Clarinet repository."),(0,r.kt)("h2",{id:"prerequisites"},"Prerequisites"),(0,r.kt)("p",null,"For this tutorial, you should have a local installation of ","[Clarinet][]",". Refer to ","[Installing Clarinet][]"," for\ninstructions on how to set up your local environment. You should also have a text editor or IDE to edit the Clarity\nsmart contract."),(0,r.kt)("p",null,"For developing the unit test, it's recommended that you have an IDE with Typescript support, such as\n","[Visual Studio Code][]","."),(0,r.kt)("p",null,"If you are using Visual Studio Code, you may want to install the ","[Clarity Visual Studio Code plugin][]","."),(0,r.kt)("h2",{id:"step-1-set-up-the-project"},"Step 1: Set up the project"),(0,r.kt)("p",null,"With Clarinet installed locally, open a new terminal window and create a new Clarinet project. Add a smart contract and\nan empty test file to the project:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-sh"},"clarinet new billboard-clarity && cd billboard-clarity\nclarinet contract new billboard\n")),(0,r.kt)("p",null,"These commands create the necessary project structure and contracts for completing this tutorial. Remember that at\nany point during this tutorial you can use ",(0,r.kt)("inlineCode",{parentName:"p"},"clarinet check")," to check the validity of your Clarity syntax."),(0,r.kt)("h2",{id:"step-2-create-message-storage"},"Step 2: Create message storage"),(0,r.kt)("p",null,"Open the ",(0,r.kt)("inlineCode",{parentName:"p"},"contracts/billboard.clar")," file in a text editor or IDE. For this tutorial, you'll use the boilerplate comments\nto structure your contract for easy readability."),(0,r.kt)("p",null,"In this step, you'll add a variable to the contract that stores the billboard message, and define a getter function to\nread the value of the variable."),(0,r.kt)("p",null,"Under the ",(0,r.kt)("inlineCode",{parentName:"p"},"data maps and vars")," comment, define the ",(0,r.kt)("inlineCode",{parentName:"p"},"billboard-message")," variable. Remember that you must define the type of\nthe variable, in this case ",(0,r.kt)("inlineCode",{parentName:"p"},"string-utf8")," to support emojis and extended characters. You must also define the\nmaximum length of the variable, for this tutorial use the value ",(0,r.kt)("inlineCode",{parentName:"p"},"500")," to allow for a longer message. You must also\ndefine the initial value for the variable."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-clarity"},';; data vars\n(define-data-var billboard-message (string-utf8 500) u"Hello world!")\n')),(0,r.kt)("p",null,"You also should define a read-only getter function returns the value of the ",(0,r.kt)("inlineCode",{parentName:"p"},"billboard-message")," variable."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-clarity"},";; public functions\n(define-read-only (get-message)\n    (var-get billboard-message))\n")),(0,r.kt)("p",null,"These are the required methods for storing and accessing the message on the billboard."),(0,r.kt)("h2",{id:"step-3-define-set-message-function"},"Step 3: Define set message function"),(0,r.kt)("p",null,"Define a method to set the billboard message. Under the public functions, define a ",(0,r.kt)("inlineCode",{parentName:"p"},"set-message")," function. This public\nfunction takes a ",(0,r.kt)("inlineCode",{parentName:"p"},"string-utf8")," with a max length of ",(0,r.kt)("inlineCode",{parentName:"p"},"500")," as the only argument. Note that the type of the argument\nmatches the type of the ",(0,r.kt)("inlineCode",{parentName:"p"},"billboard-message")," variable. Clarity's type checking ensures that an invalid input to the\nfunction doesn't execute."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-clarity"},";; public functions\n(define-public (set-message (message (string-utf8 500)))\n    (ok (var-set billboard-message message))\n)\n")),(0,r.kt)("p",null,"The contract is now capable of updating the ",(0,r.kt)("inlineCode",{parentName:"p"},"billboard-message"),"."),(0,r.kt)("h2",{id:"step-4-transfer-stx-to-set-message"},"Step 4: Transfer STX to set message"),(0,r.kt)("p",null,"In this step, you'll modify the ",(0,r.kt)("inlineCode",{parentName:"p"},"set-message")," function to add a cost in STX tokens, that increments by a set amount each\ntime the message updates."),(0,r.kt)("p",null,"First, you should define a variable to track the price of updating the billboard. This value is in micro-STX. Under the\n",(0,r.kt)("inlineCode",{parentName:"p"},"data maps and vars")," heading, add a new variable ",(0,r.kt)("inlineCode",{parentName:"p"},"price")," with type ",(0,r.kt)("inlineCode",{parentName:"p"},"uint")," and an initial value of ",(0,r.kt)("inlineCode",{parentName:"p"},"u100"),". The initial\ncost to update the billboard is 100 micro-STX or 0.0001 STX."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-clarity"},";; data vars\n(define-data-var price uint u100)\n")),(0,r.kt)("p",null,"You also should define a read-only getter function returns the value of the ",(0,r.kt)("inlineCode",{parentName:"p"},"price")," variable. Read-only functions in\nClarity are public, and should be grouped with other public functions in the contract."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-clarity"},";; public functions\n(define-read-only (get-price)\n    (var-get price)\n)\n")),(0,r.kt)("p",null,"It's a best practice to define codes to a descriptive constant for Clarity smart contracts. This makes the code easier\nto understand for readers and makes errors reusable across contract methods. Under the ",(0,r.kt)("inlineCode",{parentName:"p"},"constants")," comment, define a STX\ntransfer error constant. Assign the value ",(0,r.kt)("inlineCode",{parentName:"p"},"u0")," to the constant. There is no standard for error constants in Clarity,\nthis value is used because it's the first error the contract defines. Error constants should be defined at the top of\nthe contract, usually preceding data variables."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-clarity"},";; error consts\n(define-constant ERR_STX_TRANSFER u0)\n")),(0,r.kt)("p",null,"Modify the ",(0,r.kt)("inlineCode",{parentName:"p"},"set-message")," function to transfer the amount of STX represented by the current price of the billboard from\nthe function caller to the contract wallet address, and then increment the new price. The function is then executed in four steps: transferring STX from the function caller to the contract, updating the ",(0,r.kt)("inlineCode",{parentName:"p"},"billboard-message")," variable, incrementing the\n",(0,r.kt)("inlineCode",{parentName:"p"},"price")," variable, and returning the new price."),(0,r.kt)("p",null,"The new ",(0,r.kt)("inlineCode",{parentName:"p"},"set-message")," function uses ","[",(0,r.kt)("inlineCode",{parentName:"p"},"let"),"][]"," to define local variables for the function. Two variables are declared,\nthe ",(0,r.kt)("inlineCode",{parentName:"p"},"cur-price"),", which represents the current price of updating the billboard, and the ",(0,r.kt)("inlineCode",{parentName:"p"},"new-price"),", which represents the\nincremented price for updating the billboard."),(0,r.kt)("p",null,"The function then calls the ","[",(0,r.kt)("inlineCode",{parentName:"p"},"stx-transfer?"),"][]"," function to transfer the current price of the contract in STX from the\ntransaction sender to the contract wallet. This syntax can be confusing: the function call uses the ",(0,r.kt)("inlineCode",{parentName:"p"},"tx-sender"),"\nvariable, which is the principal address of the caller of the function. The second argument to ","[",(0,r.kt)("inlineCode",{parentName:"p"},"stx-transfer?"),"][]"," uses\nthe ","[",(0,r.kt)("inlineCode",{parentName:"p"},"as-contract"),"][]"," function to change the context's ",(0,r.kt)("inlineCode",{parentName:"p"},"tx-sender")," value to the principal address that deployed the\ncontract."),(0,r.kt)("p",null,"The entire ","[",(0,r.kt)("inlineCode",{parentName:"p"},"stx-transfer?"),"][]"," function call is wrapped in the ","[",(0,r.kt)("inlineCode",{parentName:"p"},"unwrap!"),"][]"," function, to provide protection from\nthe transfer failing. The ","[",(0,r.kt)("inlineCode",{parentName:"p"},"unwrap!"),"][]"," function executes the first argument, in this case the ","[",(0,r.kt)("inlineCode",{parentName:"p"},"stx-transfer?"),"][]","\nfunction. If the execution returns ",(0,r.kt)("inlineCode",{parentName:"p"},"(ok ...)"),", the ","[",(0,r.kt)("inlineCode",{parentName:"p"},"unwrap!"),"][]"," function returns the inner value of the ",(0,r.kt)("inlineCode",{parentName:"p"},"ok"),", otherwise\nthe function returns the second argument and exits the current control-flow, in this case the ",(0,r.kt)("inlineCode",{parentName:"p"},"ERR_STX_TRANSFER")," error\ncode."),(0,r.kt)("p",null,"If the token transfer is successful, the function sets the new ",(0,r.kt)("inlineCode",{parentName:"p"},"billboard-message")," and updates the ",(0,r.kt)("inlineCode",{parentName:"p"},"price")," variable to\n",(0,r.kt)("inlineCode",{parentName:"p"},"new-price"),". Finally, the function returns ",(0,r.kt)("inlineCode",{parentName:"p"},"(ok new-price)"),". It's generally a good practice to have public functions\nreturn ",(0,r.kt)("inlineCode",{parentName:"p"},"ok")," when successfully executed."),(0,r.kt)("admonition",{type:"note"},(0,r.kt)("p",{parentName:"admonition"},"This function should replace the existing ",(0,r.kt)("inlineCode",{parentName:"p"},"set-message")," function defined previously.")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-clarity"},"(define-public (set-message (message (string-utf8 500)))\n    (let ((cur-price (var-get price))\n          (new-price (+ cur-price u10)))\n\n        ;; pay the contract\n        (unwrap! (stx-transfer? cur-price tx-sender (as-contract tx-sender)) (err ERR_STX_TRANSFER))\n\n        ;; update the billboard's message\n        (var-set billboard-message message)\n\n        ;; update the price\n        (var-set price new-price)\n\n        ;; return the updated price\n        (ok new-price)\n    )\n)\n")),(0,r.kt)("p",null,"At this point, the final contract should look like this:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-clarity"},';; error consts\n(define-constant ERR_STX_TRANSFER u0)\n\n;; data vars\n(define-data-var billboard-message (string-utf8 500) u"Hello World!")\n(define-data-var price uint u100)\n\n;; public functions\n(define-read-only (get-price)\n    (var-get price)\n)\n\n(define-read-only (get-message)\n    (var-get billboard-message)\n)\n\n(define-public (set-message (message (string-utf8 500)))\n    (let ((cur-price (var-get price))\n          (new-price (+ cur-price u10)))\n\n        ;; pay the contract\n        (unwrap! (stx-transfer? cur-price tx-sender (as-contract tx-sender)) (err ERR_STX_TRANSFER))\n\n        ;; update the billboard\'s message\n        (var-set billboard-message message)\n\n        ;; update the price\n        (var-set price new-price)\n\n        ;; return the updated price\n        (ok new-price)\n    )\n)\n')),(0,r.kt)("p",null,"Use ",(0,r.kt)("inlineCode",{parentName:"p"},"clarinet check")," to ensure that your Clarity code is well-formed and error-free."),(0,r.kt)("h2",{id:"step-5-write-a-contract-test"},"Step 5: Write a contract test"),(0,r.kt)("p",null,"At this point, the contract functions as intended, and can be deployed to the blockchain. However, it's good practice\nto write automated testing to ensure that the contract functions perform in the expected way. Testing can be valuable\nwhen adding complexity or new functions, as working tests can verify that any changes you make didn't fundamentally\nalter the way the functions behave."),(0,r.kt)("p",null,"Open the ",(0,r.kt)("inlineCode",{parentName:"p"},"tests/billboard_test.ts")," file in your IDE. In this step, you will add a single automated test to exercise the\n",(0,r.kt)("inlineCode",{parentName:"p"},"set-message")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"get-message")," functions of the contract."),(0,r.kt)("p",null,"Using the Clarinet library, define variables to get a wallet address principal from the Clarinet configuration, and the\nbalance of that address on the chain."),(0,r.kt)("p",null,"The functional part of the test is defined using the ",(0,r.kt)("inlineCode",{parentName:"p"},"chain.mineBlock()")," function, which simulates the mining of a\nblock. Within that function, the test makes four contract calls (",(0,r.kt)("inlineCode",{parentName:"p"},"Tx.contractCall()"),"), two calls to ",(0,r.kt)("inlineCode",{parentName:"p"},"set-message")," and\ntwo calls to ",(0,r.kt)("inlineCode",{parentName:"p"},"get-message"),"."),(0,r.kt)("p",null,"Once the simulated block is mined, the test can make assertions about the chain state. This is accomplished using the\n",(0,r.kt)("inlineCode",{parentName:"p"},"assertEquals()")," function and the ",(0,r.kt)("inlineCode",{parentName:"p"},"expect")," function. In this case, the test asserts that the once the simulated block\nis mined, the block height is now equal to ",(0,r.kt)("inlineCode",{parentName:"p"},"2"),", and that the number of receipts (contract calls) in the block are\nexactly ",(0,r.kt)("inlineCode",{parentName:"p"},"4"),"."),(0,r.kt)("p",null,"The test can then make assertions about the return values of the contract. The test checks that the result of the\ntransaction calls to ",(0,r.kt)("inlineCode",{parentName:"p"},"get-message")," match the string values that the calls to ",(0,r.kt)("inlineCode",{parentName:"p"},"set-message")," contain. This covers the\ncapability of both contract functions."),(0,r.kt)("p",null,"Finally, the test asserts that STX are transferred from the transaction caller wallet, covering the price updating and\ntoken transfer. The test verifies that the addresses of the wallets match the expected addresses, and that the amount\ntransferred is the expected amount."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"import { Clarinet, Tx, Chain, Account, types } from 'https://deno.land/x/clarinet@v0.12.0/index.ts';\nimport { assertEquals } from 'https://deno.land/std@0.90.0/testing/asserts.ts';\n\nClarinet.test({\n  name: 'A quick demo on how to assert expectations',\n  async fn(chain: Chain, accounts: Map<string, Account>) {\n    let wallet_1 = accounts.get('wallet_1')!;\n    let deployer = accounts.get('deployer')!;\n    let assetMaps = chain.getAssetsMaps();\n    const balance = assetMaps.assets['STX'][wallet_1.address];\n\n    let block = chain.mineBlock([\n      Tx.contractCall('billboard', 'set-message', [types.utf8('testing')], wallet_1.address),\n      Tx.contractCall('billboard', 'get-message', [], wallet_1.address),\n      Tx.contractCall('billboard', 'set-message', [types.utf8('testing...')], wallet_1.address),\n      Tx.contractCall('billboard', 'get-message', [], wallet_1.address),\n    ]);\n\n    assertEquals(block.receipts.length, 4);\n    assertEquals(block.height, 2);\n\n    block.receipts[1].result.expectUtf8('testing');\n\n    block.receipts[3].result.expectUtf8('testing...');\n\n    let [event] = block.receipts[0].events;\n    let { sender, recipient, amount } = event.stx_transfer_event;\n    sender.expectPrincipal(wallet_1.address);\n    recipient.expectPrincipal(`${deployer.address}.billboard`);\n    amount.expectInt(100);\n\n    assetMaps = chain.getAssetsMaps();\n    assertEquals(assetMaps.assets['STX'][wallet_1.address], balance - 210);\n  },\n});\n")),(0,r.kt)("p",null,"Try running ",(0,r.kt)("inlineCode",{parentName:"p"},"clarinet test")," to see the output of the unit test."),(0,r.kt)("p",null,"You have now learned how to store and update data on chain with a variable, and how to transfer STX tokens from\na contract caller to a new principal address. Additionally, you have learned how to write a unit test for a simple\nClarity contract using Clarinet."))}u.isMDXComponent=!0}}]);