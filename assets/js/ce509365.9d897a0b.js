"use strict";(self.webpackChunk_hirosystems_docs=self.webpackChunk_hirosystems_docs||[]).push([[8702],{3905:(t,e,n)=>{n.d(e,{Zo:()=>d,kt:()=>m});var a=n(67294);function r(t,e,n){return e in t?Object.defineProperty(t,e,{value:n,enumerable:!0,configurable:!0,writable:!0}):t[e]=n,t}function o(t,e){var n=Object.keys(t);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(t);e&&(a=a.filter((function(e){return Object.getOwnPropertyDescriptor(t,e).enumerable}))),n.push.apply(n,a)}return n}function s(t){for(var e=1;e<arguments.length;e++){var n=null!=arguments[e]?arguments[e]:{};e%2?o(Object(n),!0).forEach((function(e){r(t,e,n[e])})):Object.getOwnPropertyDescriptors?Object.defineProperties(t,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(e){Object.defineProperty(t,e,Object.getOwnPropertyDescriptor(n,e))}))}return t}function i(t,e){if(null==t)return{};var n,a,r=function(t,e){if(null==t)return{};var n,a,r={},o=Object.keys(t);for(a=0;a<o.length;a++)n=o[a],e.indexOf(n)>=0||(r[n]=t[n]);return r}(t,e);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(t);for(a=0;a<o.length;a++)n=o[a],e.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(t,n)&&(r[n]=t[n])}return r}var l=a.createContext({}),c=function(t){var e=a.useContext(l),n=e;return t&&(n="function"==typeof t?t(e):s(s({},e),t)),n},d=function(t){var e=c(t.components);return a.createElement(l.Provider,{value:e},t.children)},p="mdxType",u={inlineCode:"code",wrapper:function(t){var e=t.children;return a.createElement(a.Fragment,{},e)}},h=a.forwardRef((function(t,e){var n=t.components,r=t.mdxType,o=t.originalType,l=t.parentName,d=i(t,["components","mdxType","originalType","parentName"]),p=c(n),h=r,m=p["".concat(l,".").concat(h)]||p[h]||u[h]||o;return n?a.createElement(m,s(s({ref:e},d),{},{components:n})):a.createElement(m,s({ref:e},d))}));function m(t,e){var n=arguments,r=e&&e.mdxType;if("string"==typeof t||r){var o=n.length,s=new Array(o);s[0]=h;var i={};for(var l in e)hasOwnProperty.call(e,l)&&(i[l]=e[l]);i.originalType=t,i[p]="string"==typeof t?t:r,s[1]=i;for(var c=2;c<o;c++)s[c]=n[c];return a.createElement.apply(null,s)}return a.createElement.apply(null,n)}h.displayName="MDXCreateElement"},19025:(t,e,n)=>{n.r(e),n.d(e,{assets:()=>l,contentTitle:()=>s,default:()=>u,frontMatter:()=>o,metadata:()=>i,toc:()=>c});var a=n(87462),r=(n(67294),n(3905));const o={title:"Getting Started"},s="Getting Started",i={unversionedId:"subnets/getting-started",id:"subnets/getting-started",title:"Getting Started",description:"You understand subnets from the overview\u2014now you can test one out in action. Hiro's Clarinet can serve a local subnet with clarinet integrate as one of the networks in your Stacks development environment.",source:"@site/docs/subnets/getting-started.md",sourceDirName:"subnets",slug:"/subnets/getting-started",permalink:"/doc/subnets/getting-started",draft:!1,editUrl:"https://github.com/CapybaraIO/doc/tree/main/docs/subnets/getting-started.md",tags:[],version:"current",lastUpdatedAt:1703206175,formattedLastUpdatedAt:"Dec 22, 2023",frontMatter:{title:"Getting Started"},sidebar:"subnets",previous:{title:"Overview",permalink:"/doc/subnets/"},next:{title:"Event dispatching / observer interface",permalink:"/doc/subnets/event-dispatcher"}},l={},c=[{value:"What to expect",id:"what-to-expect",level:2},{value:"Run a local subnet with Clarinet",id:"run-a-local-subnet-with-clarinet",level:2},{value:"Create a new project with Clarinet",id:"create-a-new-project-with-clarinet",level:3},{value:"Create the contracts",id:"create-the-contracts",level:3},{value:"Creating the Stacks (L1) contract",id:"creating-the-stacks-l1-contract",level:4},{value:"Creating the subnet (L2) contract",id:"creating-the-subnet-l2-contract",level:4},{value:"Configuring the Devnet",id:"configuring-the-devnet",level:3},{value:"Launching the Devnet",id:"launching-the-devnet",level:3},{value:"Setup Node.js scripts",id:"setup-nodejs-scripts",level:3},{value:"Deposit STX script",id:"deposit-stx-script",level:4},{value:"Publish contract script",id:"publish-contract-script",level:4},{value:"Register NFT script",id:"register-nft-script",level:4},{value:"Mint NFT script",id:"mint-nft-script",level:4},{value:"Deposit NFT script",id:"deposit-nft-script",level:4},{value:"Transfer NFT script",id:"transfer-nft-script",level:4},{value:"L2 withdraw script",id:"l2-withdraw-script",level:4},{value:"L1 withdraw script",id:"l1-withdraw-script",level:4},{value:"Verify script",id:"verify-script",level:4},{value:"Interacting with the subnet",id:"interacting-with-the-subnet",level:3}],d={toc:c},p="wrapper";function u(t){let{components:e,...o}=t;return(0,r.kt)(p,(0,a.Z)({},d,o,{components:e,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"getting-started"},"Getting Started"),(0,r.kt)("p",null,"You understand subnets from the ",(0,r.kt)("a",{parentName:"p",href:"/doc/subnets/"},"overview"),"\u2014now you can test one out in action. Hiro's Clarinet can serve a local subnet with ",(0,r.kt)("a",{parentName:"p",href:"/doc/clarinet/guides/how-to-run-integration-environment"},(0,r.kt)("inlineCode",{parentName:"a"},"clarinet integrate"))," as one of the networks in your Stacks development environment."),(0,r.kt)("h2",{id:"what-to-expect"},"What to expect"),(0,r.kt)("p",null,"This guide walks a user through a ",(0,r.kt)("strong",{parentName:"p"},"subnet demonstration"),": minting and transferring NFTs between a main chain (local devnet) and a subnet to showcase subnet's high throughput and low latency functionality. By the end of this guide, the user will:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Deploy the layer-1 contract that governs the interface to your subnet"),(0,r.kt)("li",{parentName:"ul"},"Deploy the layer-2 subnet contract that runs our example application\u2014an NFT contract"),(0,r.kt)("li",{parentName:"ul"},"Create the handful of ",(0,r.kt)("a",{parentName:"li",href:"https://github.com/hirosystems/stacks.js"},"Stacks.js")," scripts that will allow us to interact with our subnet and its contract application")),(0,r.kt)("p",null,"Hiro has a ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/hirosystems/subnet-demo-app"},"Subnet demo app")," demonstrating subnets' capabilities through a simple hypothetical NFT marketplace where minting, listing, and offers happen on L2. You can follow the steps by watching ",(0,r.kt)("a",{parentName:"p",href:"https://www.youtube.com/watch?v=FHKf-9C0LoI"},"this youtube presentation"),"."),(0,r.kt)("h2",{id:"run-a-local-subnet-with-clarinet"},"Run a local subnet with Clarinet"),(0,r.kt)("p",null,'Clarinet provides a tool to set up a complete local development environment, known as a "devnet", which uses Docker to spin up a Bitcoin node, a Stacks node, a Stacks API node, a Stacks Explorer, and now, a subnet node and subnet API node. This allows developers to configure a subnet and develop and test applications locally on a system that matches the production environment.'),(0,r.kt)("p",null,"In this section, we will explain how to launch and interact with the devnet's subnet node using a simple NFT example project."),(0,r.kt)("p",null,"Ensure you have ",(0,r.kt)("inlineCode",{parentName:"p"},"clarinet")," installed and the version is 1.7.1 or above. If you do not already have Clarinet installed, please refer to the Clarinet installation instructions ",(0,r.kt)("a",{parentName:"p",href:"/doc/clarinet/getting-started#install-clarinet"},"here")," for installation procedures."),(0,r.kt)("h3",{id:"create-a-new-project-with-clarinet"},"Create a new project with Clarinet"),(0,r.kt)("p",null,"To create a new project, run:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-sh"},"clarinet new subnet-nft-example\ncd subnet-nft-example\n")),(0,r.kt)("p",null,"This command creates a new directory with a Clarinet project already initialized, and then switches into that directory."),(0,r.kt)("h3",{id:"create-the-contracts"},"Create the contracts"),(0,r.kt)("p",null,"While this guide does involve writing and publishing a Clarity contract to your local subnet, Clarinet does not yet support contract deployment to subnets directly. Instead, we will manually deploy the contract through a Stacks.js script in a later step."),(0,r.kt)("h4",{id:"creating-the-stacks-l1-contract"},"Creating the Stacks (L1) contract"),(0,r.kt)("p",null,"Our first contract will be the L1 contract that serves as an interface with the subnet node, in this instance allowing us to mint and transfer NFTs between the layers. Our L1 NFT contract is going to implement the ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/stacksgov/sips/blob/main/sips/sip-009/sip-009-nft-standard.md#trait"},"SIP-009 NFT trait"),"."),(0,r.kt)("p",null,"We will add this to our project as a requirement so that Clarinet will deploy it for us."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-sh"},"clarinet requirements add ST1NXBK3K5YYMD6FD41MVNP3JS1GABZ8TRVX023PT.nft-trait\n")),(0,r.kt)("p",null,"We'll also use a new trait defined for the subnet, ",(0,r.kt)("inlineCode",{parentName:"p"},"mint-from-subnet-trait"),", that allows the subnet to mint a new asset on the Stacks chain if it was originally minted on the subnet and then withdrawn. We will add a requirement for this contract as well:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-sh"},"clarinet requirements add ST13F481SBR0R7Z6NMMH8YV2FJJYXA5JPA0AD3HP9.subnet-traits-v1\n")),(0,r.kt)("p",null,"Now, we will use Clarinet to create our L1 contract:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-sh"},"clarinet contract new simple-nft-l1\n")),(0,r.kt)("p",null,"This creates the file, ",(0,r.kt)("em",{parentName:"p"},"./contracts/simple-nft-l1.clar"),". Open the file and add the following content:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-clarity"},"(define-constant CONTRACT_OWNER tx-sender)\n(define-constant CONTRACT_ADDRESS (as-contract tx-sender))\n\n(define-constant ERR_NOT_AUTHORIZED (err u1001))\n\n(impl-trait 'ST1NXBK3K5YYMD6FD41MVNP3JS1GABZ8TRVX023PT.nft-trait.nft-trait)\n(impl-trait 'ST13F481SBR0R7Z6NMMH8YV2FJJYXA5JPA0AD3HP9.subnet-traits-v1.mint-from-subnet-trait)\n\n(define-data-var lastId uint u0)\n(define-map CFG_BASE_URI bool (string-ascii 256))\n\n(define-non-fungible-token nft-token uint)\n\n(define-read-only (get-last-token-id)\n  (ok (var-get lastId))\n)\n\n(define-read-only (get-owner (id uint))\n  (ok (nft-get-owner? nft-token id))\n)\n\n(define-read-only (get-token-uri (id uint))\n  (ok (map-get? CFG_BASE_URI true))\n)\n\n(define-public (transfer (id uint) (sender principal) (recipient principal))\n  (begin\n    (asserts! (is-eq tx-sender sender) ERR_NOT_AUTHORIZED)\n    (nft-transfer? nft-token id sender recipient)\n  )\n)\n\n;; test functions\n(define-public (test-mint (recipient principal))\n  (let\n    ((newId (+ (var-get lastId) u1)))\n    (var-set lastId newId)\n    (nft-mint? nft-token newId recipient)\n  )\n)\n\n(define-public (mint-from-subnet (id uint) (sender principal) (recipient principal))\n    (begin\n        ;; Check that the tx-sender is the provided sender\n        (asserts! (is-eq tx-sender sender) ERR_NOT_AUTHORIZED)\n\n        (nft-mint? nft-token id recipient)\n    )\n)\n\n(define-public (gift-nft (recipient principal) (id uint))\n  (begin\n    (nft-mint? nft-token id recipient)\n  )\n)\n")),(0,r.kt)("admonition",{type:"note"},(0,r.kt)("p",{parentName:"admonition"},(0,r.kt)("em",{parentName:"p"},"This contract implements the ",(0,r.kt)("inlineCode",{parentName:"em"},"mint-from-subnet-trait")," and the SIP-009 ",(0,r.kt)("inlineCode",{parentName:"em"},"nft-trait.")," When ",(0,r.kt)("inlineCode",{parentName:"em"},"mint-from-subnet-trait")," is implemented, it allows an NFT to be minted on the subnet, then later withdrawn to the L1."))),(0,r.kt)("h4",{id:"creating-the-subnet-l2-contract"},"Creating the subnet (L2) contract"),(0,r.kt)("p",null,"Next, we will manually create the subnet contract at ",(0,r.kt)("em",{parentName:"p"},"./contracts/simple-nft-l2.clar"),'. This can be accomplished using the "New File..." interface in your editor, or with ',(0,r.kt)("inlineCode",{parentName:"p"},"touch contracts/simple-nft-l2.clar")," in the terminal."),(0,r.kt)("admonition",{type:"note"},(0,r.kt)("p",{parentName:"admonition"},(0,r.kt)("em",{parentName:"p"},"We are not using Clarinet to add this contract because we do not want it to be deployed on the Stacks network, and Clarinet does not yet support deployment on the subnet. Instead, in a later step, we will write and run a Stacks.js script that communicates to the subnet node to deploy this contract."))),(0,r.kt)("p",null,"Open the new file and add the following content:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-clarity"},"(define-constant CONTRACT_OWNER tx-sender)\n(define-constant CONTRACT_ADDRESS (as-contract tx-sender))\n\n(define-constant ERR_NOT_AUTHORIZED (err u1001))\n\n(impl-trait 'ST000000000000000000002AMW42H.subnet.nft-trait)\n\n(define-data-var lastId uint u0)\n\n(define-non-fungible-token nft-token uint)\n\n\n;; NFT trait functions\n(define-read-only (get-last-token-id)\n  (ok (var-get lastId))\n)\n\n(define-read-only (get-owner (id uint))\n  (ok (nft-get-owner? nft-token id))\n)\n\n(define-read-only (get-token-uri (id uint))\n  (ok (some \"unimplemented\"))\n)\n\n(define-public (transfer (id uint) (sender principal) (recipient principal))\n  (begin\n    (asserts! (is-eq tx-sender sender) ERR_NOT_AUTHORIZED)\n    (nft-transfer? nft-token id sender recipient)\n  )\n)\n\n;; mint functions\n(define-public (mint-next (recipient principal))\n  (let\n    ((newId (+ (var-get lastId) u1)))\n    (var-set lastId newId)\n    (nft-mint? nft-token newId recipient)\n  )\n)\n\n(define-public (gift-nft (recipient principal) (id uint))\n  (begin\n    (nft-mint? nft-token id recipient)\n  )\n)\n\n(define-read-only (get-token-owner (id uint))\n  (nft-get-owner? nft-token id)\n)\n\n(impl-trait 'ST000000000000000000002AMW42H.subnet.subnet-asset)\n\n;; Called for deposit from the burnchain to the subnet\n(define-public (deposit-from-burnchain (id uint) (recipient principal))\n  (begin\n    (asserts! (is-eq tx-sender 'ST000000000000000000002AMW42H) ERR_NOT_AUTHORIZED)\n    (nft-mint? nft-token id recipient)\n  )\n)\n\n;; Called for withdrawal from the subnet to the burnchain\n(define-public (burn-for-withdrawal (id uint) (owner principal))\n  (begin\n    (asserts! (is-eq tx-sender owner) ERR_NOT_AUTHORIZED)\n    (nft-burn? nft-token id owner)\n  )\n)\n")),(0,r.kt)("p",null,"This contract implements the ",(0,r.kt)("inlineCode",{parentName:"p"},"nft-trait")," and the ",(0,r.kt)("inlineCode",{parentName:"p"},"subnet-asset")," trait. The ",(0,r.kt)("inlineCode",{parentName:"p"},"nft-trait")," is the same as the SIP-009 trait on the Stacks network. ",(0,r.kt)("inlineCode",{parentName:"p"},"subnet-asset")," defines the functions required for deposit and withdrawal. ",(0,r.kt)("inlineCode",{parentName:"p"},"deposit-from-burnchain")," is invoked by the subnet node's consensus logic whenever a deposit is made in layer-1. ",(0,r.kt)("inlineCode",{parentName:"p"},"burn-for-withdrawal")," is invoked by the ",(0,r.kt)("inlineCode",{parentName:"p"},"nft-withdraw?")," or ",(0,r.kt)("inlineCode",{parentName:"p"},"ft-withdraw?")," functions of the subnet contract, that a user calls when they wish to withdraw their asset from the subnet back to the layer-1."),(0,r.kt)("h3",{id:"configuring-the-devnet"},"Configuring the Devnet"),(0,r.kt)("p",null,"The settings for the devnet are found in ",(0,r.kt)("em",{parentName:"p"},"./settings/Devnet.toml"),". In order to launch a subnet in the devnet, we need to tell Clarinet to enable a subnet node and a corresponding API node. Open the file and uncomment or add the following lines under ",(0,r.kt)("inlineCode",{parentName:"p"},"[devnet]"),":"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-toml"},"enable_subnet_node = true\n")),(0,r.kt)("p",null,"Also, we can see a few default settings that ",(0,r.kt)("inlineCode",{parentName:"p"},"clarinet")," will be using for our subnet. It is not necessary to modify any of these settings, but doing so allows you to customize your test environment."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-toml"},'# L1 Subnet contract which the subnet will attempt to communicate with\nsubnet_contract_id = "ST167FDXCJGS54J1T0J42VTX46G0QQQFRJGBK28RN.subnet-v3-0-1"\n# Docker image of subnet node\nsubnet_node_image_url = "hirosystems/stacks-subnets:0.8.1"\n# Docker image of subnet API\nsubnet_api_image_url = "hirosystems/stacks-blockchain-api:latest"\n')),(0,r.kt)("h3",{id:"launching-the-devnet"},"Launching the Devnet"),(0,r.kt)("p",null,"Once the configuration is complete, run the following command to start the devnet environment:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-sh"},"clarinet integrate\n")),(0,r.kt)("p",null,"This will launch docker containers for a bitcoin node, a Stacks node, the Stacks API service, a subnet node, the subnet API service, and an explorer service. While running, ",(0,r.kt)("inlineCode",{parentName:"p"},"clarinet integrate")," opens a terminal UI that shows various data points about the state of the network."),(0,r.kt)("p",null,"All of the nodes and services are running and ready when we see:"),(0,r.kt)("p",null,(0,r.kt)("img",{alt:"Clarinet integrate services",src:n(25759).Z,width:"1248",height:"268"})),(0,r.kt)("p",null,"Once this state is reached, we should see successful calls to ",(0,r.kt)("inlineCode",{parentName:"p"},"commit-block")," in the transactions console. This is the subnet miner committing blocks to the L1. Leave this running and perform the next steps in another terminal."),(0,r.kt)("h3",{id:"setup-nodejs-scripts"},"Setup Node.js scripts"),(0,r.kt)("p",null,"Clarinet does not yet support direct interaction with the subnet node through deployment plans. Instead, we will interact with our subnet node with ",(0,r.kt)("a",{parentName:"p",href:"https://stacks.js.org"},"Stacks.js")," scripts."),(0,r.kt)("p",null,"By the end of this section, we will have these several scripts that correspond to the various kinds of functionality we can invoke from our application:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("em",{parentName:"li"},"deposit-stx.js")," - deposit STX into the subnet"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("em",{parentName:"li"},"publish.js")," - publish a smart contract"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("em",{parentName:"li"},"register.js")," - register an NFT with the subnet so it can be deposited and withdrawn"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("em",{parentName:"li"},"mint.js")," - mint a new NFT on the L1 (devnet)"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("em",{parentName:"li"},"deposit.js")," - deposit the NFT into the subnet by by calling the ",(0,r.kt)("inlineCode",{parentName:"li"},"deposit-nft-asset")," function on the L1 subnet contract"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("em",{parentName:"li"},"transfer.js")," - transfer the NFT from one user to another in the subnet"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("em",{parentName:"li"},"withdraw-l2.js")," - the two-step withdrawal process starts with withdrawing an asset from the L2 (subnet)"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("em",{parentName:"li"},"withdraw-l1.js")," - the second step to withdrawal is a call to ",(0,r.kt)("inlineCode",{parentName:"li"},"withdraw-nft-asset")," on the L1 subnet contract"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("em",{parentName:"li"},"verify.js")," - querying the current owner of an NFT")),(0,r.kt)("p",null,"We will save these scripts in a new directory, ",(0,r.kt)("em",{parentName:"p"},"./scripts/"),"."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-sh"},"mkdir scripts\ncd scripts\ntouch {deposit-stx,publish,register,mint,deposit,transfer,withdraw-l2,withdraw-l1,verify}.js\n")),(0,r.kt)("p",null,"Then we will initialize a Node.js project and install the Stacks.js dependencies:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-sh"},"npm init -y\nnpm install @stacks/network @stacks/transactions\n")),(0,r.kt)("p",null,"In the generated ",(0,r.kt)("inlineCode",{parentName:"p"},"package.json")," file, add the following into the ",(0,r.kt)("inlineCode",{parentName:"p"},"json")," to enable modules:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-json"},'  "type": "module",\n')),(0,r.kt)("p",null,"To simplify our scripts, we will define some environment variables in our terminal that will be used to hold the signing keys for various subnet transactions."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-sh"},'export DEPLOYER_ADDR=ST1PQHQKV0RJXZFY1DGX8MNSNYVE3VGZJSRTPGZGM\nexport DEPLOYER_KEY=753b7cc01a1a2e86221266a154af739463fce51219d97e4f856cd7200c3bd2a601\n\nexport USER_ADDR=ST2NEB84ASENDXKYGJPQW86YXQCEFEX2ZQPG87ND\nexport USER_KEY=f9d7206a47f14d2870c163ebab4bf3e70d18f5d14ce1031f3902fbbc894fe4c701\n\nexport ALT_USER_ADDR=ST2REHHS5J3CERCRBEPMGH7921Q6PYKAADT7JP2VB\nexport ALT_USER_KEY=3eccc5dac8056590432db6a35d52b9896876a3d5cbdea53b72400bc9c2099fe801\n\nexport SUBNET_URL="http://localhost:30443"\nexport SUBNET_CHAIN_ID=1426085120\n')),(0,r.kt)("h4",{id:"deposit-stx-script"},"Deposit STX script"),(0,r.kt)("p",null,"We'll start with a script to deposit STX into the subnet accounts. Without first depositing any STX, we wouldn't be able to pay the fees on the subnet. This script adds 5 STX to each account that we'll be making transactions from."),(0,r.kt)("p",null,(0,r.kt)("em",{parentName:"p"},"deposit-stx.js"),":"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},"import {\n  makeContractCall,\n  AnchorMode,\n  standardPrincipalCV,\n  uintCV,\n  PostConditionMode,\n  broadcastTransaction,\n} from '@stacks/transactions';\nimport { StacksTestnet, HIRO_MOCKNET_DEFAULT } from '@stacks/network';\n\nasync function main() {\n  const network = new StacksTestnet({ url: HIRO_MOCKNET_DEFAULT });\n  const nonce = 0;\n\n  let txOptions = {\n    contractAddress: 'ST1PQHQKV0RJXZFY1DGX8MNSNYVE3VGZJSRTPGZGM',\n    contractName: 'subnet-v3-0-1',\n    functionName: 'deposit-stx',\n    functionArgs: [\n      uintCV(5000000), // amount\n      standardPrincipalCV(process.env.USER_ADDR), // sender\n    ],\n    senderKey: process.env.USER_KEY,\n    validateWithAbi: false,\n    network,\n    anchorMode: AnchorMode.Any,\n    fee: 10000,\n    postConditionMode: PostConditionMode.Allow,\n    nonce,\n  };\n\n  let transaction = await makeContractCall(txOptions);\n\n  let txid = await broadcastTransaction(transaction, network);\n\n  console.log(txid);\n\n  txOptions = {\n    contractAddress: 'ST1PQHQKV0RJXZFY1DGX8MNSNYVE3VGZJSRTPGZGM',\n    contractName: 'subnet-v3-0-1',\n    functionName: 'deposit-stx',\n    functionArgs: [\n      uintCV(5000000), // amount\n      standardPrincipalCV(process.env.ALT_USER_ADDR), // sender\n    ],\n    senderKey: process.env.ALT_USER_KEY,\n    validateWithAbi: false,\n    network,\n    anchorMode: AnchorMode.Any,\n    fee: 10000,\n    postConditionMode: PostConditionMode.Allow,\n    nonce,\n  };\n\n  transaction = await makeContractCall(txOptions);\n\n  txid = await broadcastTransaction(transaction, network);\n\n  console.log(txid);\n}\n\nmain();\n")),(0,r.kt)("h4",{id:"publish-contract-script"},"Publish contract script"),(0,r.kt)("p",null,"Next, we'll add a script to publish a contract. To make it reusable, we will allow this script to handle some command line arguments:"),(0,r.kt)("ol",null,(0,r.kt)("li",{parentName:"ol"},"Contract name"),(0,r.kt)("li",{parentName:"ol"},"Path to contract"),(0,r.kt)("li",{parentName:"ol"},"Network layer (1 = Stacks, 2 = Subnet)"),(0,r.kt)("li",{parentName:"ol"},"The deployer's current account nonce")),(0,r.kt)("p",null,(0,r.kt)("em",{parentName:"p"},"publish.js"),":"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},"import { AnchorMode, makeContractDeploy, broadcastTransaction } from '@stacks/transactions';\nimport { StacksTestnet, HIRO_MOCKNET_DEFAULT } from '@stacks/network';\nimport { readFileSync } from 'fs';\n\nasync function main() {\n  const contractName = process.argv[2];\n  const contractFilename = process.argv[3];\n  const networkLayer = parseInt(process.argv[4]);\n  const nonce = parseInt(process.argv[5]);\n  const senderKey = process.env.USER_KEY;\n  let network = null;\n  if (networkLayer == 1) {\n    network = new StacksTestnet({ url: HIRO_MOCKNET_DEFAULT });\n  } else if (networkLayer == 2) {\n    network = new StacksTestnet({ url: process.env.SUBNET_URL });\n    network.chainId = process.env.SUBNET_CHAIN_ID;\n  } else {\n    console.log(`Invalid networkLayer: ${networkLayer}`);\n    return 1;\n  }\n\n  const codeBody = readFileSync(contractFilename, { encoding: 'utf-8' });\n\n  const transaction = await makeContractDeploy({\n    codeBody,\n    contractName,\n    senderKey,\n    network,\n    anchorMode: AnchorMode.Any,\n    fee: 10000,\n    nonce,\n  });\n\n  const txid = await broadcastTransaction(transaction, network);\n\n  console.log(txid);\n}\n\nmain();\n")),(0,r.kt)("h4",{id:"register-nft-script"},"Register NFT script"),(0,r.kt)("p",null,"We also need to register our NFT with our subnet, allowing it to be deposited into the subnet. To do this, we'll write another script, but because we only need to do this once, we will hardcode our details into the script."),(0,r.kt)("p",null,"This script calls ",(0,r.kt)("inlineCode",{parentName:"p"},"register-new-nft-contract")," on the L1 subnet contract, passing the L1 and L2 NFT contracts we will publish."),(0,r.kt)("p",null,(0,r.kt)("em",{parentName:"p"},"register.js"),":"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},"import {\n  makeContractCall,\n  AnchorMode,\n  contractPrincipalCV,\n  broadcastTransaction,\n  getNonce,\n} from '@stacks/transactions';\nimport { StacksTestnet, HIRO_MOCKNET_DEFAULT } from '@stacks/network';\n\nasync function main() {\n  const network = new StacksTestnet({ url: HIRO_MOCKNET_DEFAULT });\n  const senderKey = process.env.DEPLOYER_KEY;\n  const deployerAddr = process.env.DEPLOYER_ADDR;\n  const userAddr = process.env.USER_ADDR;\n  const nonce = (await getNonce(deployerAddr, network)) + BigInt(1);\n\n  const txOptions = {\n    contractAddress: 'ST1PQHQKV0RJXZFY1DGX8MNSNYVE3VGZJSRTPGZGM',\n    contractName: 'subnet-v3-0-1',\n    functionName: 'register-new-nft-contract',\n    functionArgs: [\n      contractPrincipalCV(deployerAddr, 'simple-nft-l1'),\n      contractPrincipalCV(userAddr, 'simple-nft-l2'),\n    ],\n    senderKey,\n    validateWithAbi: false,\n    network,\n    anchorMode: AnchorMode.Any,\n    fee: 10000,\n    nonce,\n  };\n\n  const transaction = await makeContractCall(txOptions);\n\n  const txid = await broadcastTransaction(transaction, network);\n\n  console.log(txid);\n}\n\nmain();\n")),(0,r.kt)("h4",{id:"mint-nft-script"},"Mint NFT script"),(0,r.kt)("p",null,"In order to move NFTs to and from the subnet, we will need to have some NFTs on our devnet. To do this, we need to mint, so we also write a script for submitting NFT mint transactions to the layer-1 network. This script takes just one argument: the user's current account nonce."),(0,r.kt)("p",null,(0,r.kt)("em",{parentName:"p"},"mint.js"),":"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},"import {\n  makeContractCall,\n  AnchorMode,\n  standardPrincipalCV,\n  uintCV,\n  broadcastTransaction,\n} from '@stacks/transactions';\nimport { StacksTestnet, HIRO_MOCKNET_DEFAULT } from '@stacks/network';\n\nasync function main() {\n  const network = new StacksTestnet({ url: HIRO_MOCKNET_DEFAULT });\n  const senderKey = process.env.USER_KEY;\n  const deployerAddr = process.env.DEPLOYER_ADDR;\n  const addr = process.env.USER_ADDR;\n  const nonce = parseInt(process.argv[2]);\n\n  const txOptions = {\n    contractAddress: deployerAddr,\n    contractName: 'simple-nft-l1',\n    functionName: 'gift-nft',\n    functionArgs: [standardPrincipalCV(addr), uintCV(5)],\n    senderKey,\n    validateWithAbi: false,\n    network,\n    anchorMode: AnchorMode.Any,\n    fee: 10000,\n    nonce,\n  };\n\n  const transaction = await makeContractCall(txOptions);\n\n  const txid = await broadcastTransaction(transaction, network);\n\n  console.log(txid);\n}\n\nmain();\n")),(0,r.kt)("h4",{id:"deposit-nft-script"},"Deposit NFT script"),(0,r.kt)("p",null,"We also want to be able to deposit an asset into the subnet. To do this, we will write another script to call the ",(0,r.kt)("inlineCode",{parentName:"p"},"deposit-nft-asset")," function on the layer-1 subnet contract. Like the NFT minting script, this script takes just one argument: the user's current account nonce."),(0,r.kt)("p",null,(0,r.kt)("em",{parentName:"p"},"deposit.js")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},"import {\n  makeContractCall,\n  AnchorMode,\n  standardPrincipalCV,\n  uintCV,\n  contractPrincipalCV,\n  PostConditionMode,\n  broadcastTransaction,\n} from '@stacks/transactions';\nimport { StacksTestnet, HIRO_MOCKNET_DEFAULT } from '@stacks/network';\n\nasync function main() {\n  const network = new StacksTestnet({ url: HIRO_MOCKNET_DEFAULT });\n  const senderKey = process.env.USER_KEY;\n  const addr = process.env.USER_ADDR;\n  const deployerAddr = process.env.DEPLOYER_ADDR;\n  const nonce = parseInt(process.argv[2]);\n\n  const txOptions = {\n    contractAddress: 'ST1PQHQKV0RJXZFY1DGX8MNSNYVE3VGZJSRTPGZGM',\n    contractName: 'subnet-v3-0-1',\n    functionName: 'deposit-nft-asset',\n    functionArgs: [\n      contractPrincipalCV(deployerAddr, 'simple-nft-l1'), // contract ID of nft contract on L1\n      uintCV(5), // ID\n      standardPrincipalCV(addr), // sender\n    ],\n    senderKey,\n    validateWithAbi: false,\n    network,\n    anchorMode: AnchorMode.Any,\n    fee: 10000,\n    postConditionMode: PostConditionMode.Allow,\n    nonce,\n  };\n\n  const transaction = await makeContractCall(txOptions);\n\n  const txid = await broadcastTransaction(transaction, network);\n\n  console.log(txid);\n}\n\nmain();\n")),(0,r.kt)("h4",{id:"transfer-nft-script"},"Transfer NFT script"),(0,r.kt)("p",null,"We will want to transfer an NFT from one user to another to demonstrate some subnet transactions. We will write another script to invoke the NFT's ",(0,r.kt)("inlineCode",{parentName:"p"},"transfer")," function in the subnet. Again, this script takes just one argument: the user's current account nonce."),(0,r.kt)("p",null,(0,r.kt)("em",{parentName:"p"},"transfer.js")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},"import {\n  makeContractCall,\n  AnchorMode,\n  standardPrincipalCV,\n  uintCV,\n  PostConditionMode,\n  broadcastTransaction,\n} from '@stacks/transactions';\nimport { StacksTestnet } from '@stacks/network';\n\nasync function main() {\n  let network = new StacksTestnet({ url: process.env.SUBNET_URL });\n  network.chainId = process.env.SUBNET_CHAIN_ID;\n  const senderKey = process.env.USER_KEY;\n  const addr = process.env.USER_ADDR;\n  const alt_addr = process.env.ALT_USER_ADDR;\n  const nonce = parseInt(process.argv[2]);\n\n  const txOptions = {\n    contractAddress: addr,\n    contractName: 'simple-nft-l2',\n    functionName: 'transfer',\n    functionArgs: [\n      uintCV(5), // ID\n      standardPrincipalCV(addr), // sender\n      standardPrincipalCV(alt_addr), // recipient\n    ],\n    senderKey,\n    validateWithAbi: false,\n    network,\n    anchorMode: AnchorMode.Any,\n    fee: 10000,\n    nonce,\n    postConditionMode: PostConditionMode.Allow,\n  };\n\n  const transaction = await makeContractCall(txOptions);\n\n  const txid = await broadcastTransaction(transaction, network);\n\n  console.log(txid);\n}\n\nmain();\n")),(0,r.kt)("h4",{id:"l2-withdraw-script"},"L2 withdraw script"),(0,r.kt)("p",null,"In order to withdraw an asset from a subnet, users must first submit a withdraw transaction on that subnet. To support this, we will write a script that invokes the ",(0,r.kt)("inlineCode",{parentName:"p"},"nft-withdraw?")," method on the layer-2 subnet contract. This script takes just a single argument: the user's current account nonce."),(0,r.kt)("p",null,(0,r.kt)("em",{parentName:"p"},"withdraw-l2.js")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},"import {\n  makeContractCall,\n  AnchorMode,\n  standardPrincipalCV,\n  contractPrincipalCV,\n  uintCV,\n  broadcastTransaction,\n  PostConditionMode,\n} from '@stacks/transactions';\nimport { StacksTestnet } from '@stacks/network';\n\nasync function main() {\n  let network = new StacksTestnet({ url: process.env.SUBNET_URL });\n  network.chainId = process.env.SUBNET_CHAIN_ID;\n  const senderKey = process.env.ALT_USER_KEY;\n  const contractAddr = process.env.USER_ADDR;\n  const addr = process.env.ALT_USER_ADDR;\n  const nonce = parseInt(process.argv[2]);\n\n  const txOptions = {\n    contractAddress: 'ST000000000000000000002AMW42H',\n    contractName: 'subnet',\n    functionName: 'nft-withdraw?',\n    functionArgs: [\n      contractPrincipalCV(contractAddr, 'simple-nft-l2'),\n      uintCV(5), // ID\n      standardPrincipalCV(addr), // recipient\n    ],\n    senderKey,\n    validateWithAbi: false,\n    network,\n    anchorMode: AnchorMode.Any,\n    fee: 10000,\n    nonce,\n    postConditionMode: PostConditionMode.Allow,\n  };\n\n  const transaction = await makeContractCall(txOptions);\n\n  const txid = await broadcastTransaction(transaction, network);\n\n  console.log(txid);\n}\n\nmain();\n")),(0,r.kt)("h4",{id:"l1-withdraw-script"},"L1 withdraw script"),(0,r.kt)("p",null,"The second step of a withdrawal is to call the ",(0,r.kt)("inlineCode",{parentName:"p"},"withdraw-nft-asset")," method on the layer-1 subnet contract. This method requires information from the subnet to verify that the withdrawal is valid. We will write a script that queries our subnet node's RPC interface for this information and then issues the layer-1 withdrawal transaction."),(0,r.kt)("p",null,"This script has two input arguments: the (subnet) block height of the layer-2 withdrawal transaction, and the user's current account nonce."),(0,r.kt)("p",null,(0,r.kt)("em",{parentName:"p"},"withdraw-l1.js")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},"import {\n  makeContractCall,\n  deserializeCV,\n  AnchorMode,\n  standardPrincipalCV,\n  uintCV,\n  someCV,\n  PostConditionMode,\n  contractPrincipalCV,\n  broadcastTransaction,\n} from '@stacks/transactions';\nimport { StacksTestnet, HIRO_MOCKNET_DEFAULT } from '@stacks/network';\n\nasync function main() {\n  const network = new StacksTestnet({ url: HIRO_MOCKNET_DEFAULT });\n  const subnetUrl = process.env.SUBNET_URL;\n  const senderKey = process.env.ALT_USER_KEY;\n  const addr = process.env.ALT_USER_ADDR;\n  const l1ContractAddr = process.env.DEPLOYER_ADDR;\n  const l2ContractAddr = process.env.USER_ADDR;\n  const withdrawalBlockHeight = process.argv[2];\n  const nonce = parseInt(process.argv[3]);\n  const withdrawalId = 0;\n\n  let json_merkle_entry = await fetch(\n    `${subnetUrl}/v2/withdrawal/nft/${withdrawalBlockHeight}/${addr}/${withdrawalId}/${l2ContractAddr}/simple-nft-l2/5`\n  ).then(x => x.json());\n  let cv_merkle_entry = {\n    withdrawal_leaf_hash: deserializeCV(json_merkle_entry.withdrawal_leaf_hash),\n    withdrawal_root: deserializeCV(json_merkle_entry.withdrawal_root),\n    sibling_hashes: deserializeCV(json_merkle_entry.sibling_hashes),\n  };\n\n  const txOptions = {\n    senderKey,\n    network,\n    anchorMode: AnchorMode.Any,\n    contractAddress: 'ST1PQHQKV0RJXZFY1DGX8MNSNYVE3VGZJSRTPGZGM',\n    contractName: 'subnet-v3-0-1',\n    functionName: 'withdraw-nft-asset',\n    functionArgs: [\n      contractPrincipalCV(l1ContractAddr, 'simple-nft-l1'), // nft-contract\n      uintCV(5), // ID\n      standardPrincipalCV(addr), // recipient\n      uintCV(withdrawalId), // withdrawal ID\n      uintCV(withdrawalBlockHeight), // withdrawal block height\n      someCV(contractPrincipalCV(l1ContractAddr, 'simple-nft-l1')), // nft-mint-contract\n      cv_merkle_entry.withdrawal_root, // withdrawal root\n      cv_merkle_entry.withdrawal_leaf_hash, // withdrawal leaf hash\n      cv_merkle_entry.sibling_hashes,\n    ], // sibling hashes\n    fee: 10000,\n    postConditionMode: PostConditionMode.Allow,\n    nonce,\n  };\n\n  const transaction = await makeContractCall(txOptions);\n\n  const txid = await broadcastTransaction(transaction, network);\n\n  console.log(txid);\n}\n\nmain();\n")),(0,r.kt)("h4",{id:"verify-script"},"Verify script"),(0,r.kt)("p",null,"Lastly, we need a simple way to query for the current owner of an NFT, so we will write a script that invokes the read-only ",(0,r.kt)("inlineCode",{parentName:"p"},"get-owner")," function via either the subnet or stacks node's RPC interface. This script takes just one argument indicating whether it should query the subnet (",(0,r.kt)("inlineCode",{parentName:"p"},"2"),") or the stacks node (",(0,r.kt)("inlineCode",{parentName:"p"},"1"),")."),(0,r.kt)("p",null,(0,r.kt)("em",{parentName:"p"},"verify.js")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},"import { uintCV, callReadOnlyFunction, cvToString } from '@stacks/transactions';\nimport { StacksTestnet, HIRO_MOCKNET_DEFAULT } from '@stacks/network';\n\nasync function main() {\n  const networkLayer = parseInt(process.argv[2]);\n  const senderAddress = process.env.ALT_USER_ADDR;\n  let contractAddress = null;\n  let contractName = null;\n  let network = null;\n\n  if (networkLayer == 1) {\n    contractName = 'simple-nft-l1';\n    contractAddress = process.env.DEPLOYER_ADDR;\n    network = new StacksTestnet({ url: HIRO_MOCKNET_DEFAULT });\n  } else if (networkLayer == 2) {\n    contractName = 'simple-nft-l2';\n    contractAddress = process.env.USER_ADDR;\n    network = new StacksTestnet({ url: process.env.SUBNET_URL });\n    network.chainId = process.env.SUBNET_CHAIN_ID;\n  } else {\n    console.log(`Invalid networkLayer: ${networkLayer}`);\n    return 1;\n  }\n\n  const txOptions = {\n    contractAddress,\n    contractName,\n    functionName: 'get-owner',\n    functionArgs: [uintCV(5)],\n    network,\n    senderAddress,\n  };\n\n  const result = await callReadOnlyFunction(txOptions);\n\n  console.log(cvToString(result.value));\n}\n\nmain();\n")),(0,r.kt)("h3",{id:"interacting-with-the-subnet"},"Interacting with the subnet"),(0,r.kt)("p",null,"We will now use this set of scripts to demonstrate a subnet's functionality. We will:"),(0,r.kt)("ol",null,(0,r.kt)("li",{parentName:"ol"},"Deposit some STX into the subnet, so that we can pay transaction fees"),(0,r.kt)("li",{parentName:"ol"},"Publish our NFT contract on the subnet"),(0,r.kt)("li",{parentName:"ol"},"Mint a new NFT in the stacks network"),(0,r.kt)("li",{parentName:"ol"},"Deposit this NFT into the subnet"),(0,r.kt)("li",{parentName:"ol"},"Transfer the NFT from one user to another in the subnet"),(0,r.kt)("li",{parentName:"ol"},"Withdraw the NFT from the subnet")),(0,r.kt)("p",null,"First, we will deposit 5 STX into the subnet for each of our users:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-sh"},"node ./deposit-stx.js\n")),(0,r.kt)("p",null,"Since this is an L1 transaction, we can see it in Clarinet's terminal interface, or look for it in the Stacks Explorer, at ",(0,r.kt)("inlineCode",{parentName:"p"},"http://localhost:8000"),'. Once this transaction has been confirmed in the L1, it will also trigger a STX transfer in the L2. To see that, we can add the subnet to the Explorer as a new network. To switch to the subnet, select "Network" in the top right, then "Add a network." In the popup, choose a name, e.g. "Devnet Subnet", and then for the URL, use ',(0,r.kt)("inlineCode",{parentName:"p"},"http://localhost:13999"),". Once we see a STX transfer of 5.00 STX, we'll know that the deposit was successful."),(0,r.kt)("p",null,(0,r.kt)("img",{alt:"STX deposit successful",src:n(17140).Z,width:"1558",height:"184"})),(0,r.kt)("p",null,"Next, we will publish the L2 NFT contract to the subnet:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-sh"},"node ./publish.js simple-nft-l2 ../contracts/simple-nft-l2.clar 2 0\n")),(0,r.kt)("p",null,'Clarinet\'s terminal interface does not show the transactions on the subnet, but now we can see the transaction in the subnet explorer that we just set up. You will know this contract deployment succeeded when you see the contract deploy transaction for "simple-nft-l2" in the list of confirmed transactions. Be sure to confirm transactions before proceeding.'),(0,r.kt)("p",null,(0,r.kt)("img",{alt:"contract deploy confirmed",src:n(6215).Z,width:"706",height:"492"})),(0,r.kt)("admonition",{type:"note"},(0,r.kt)("p",{parentName:"admonition"},(0,r.kt)("em",{parentName:"p"},"Each of these scripts depend upon the prior transaction to be published to either the L1 devnet or the L2 subnet before the next transaction can be completed successfully (for instance, the ",(0,r.kt)("inlineCode",{parentName:"em"},"register.js")," transaction must be published to a devnet block before the ",(0,r.kt)("inlineCode",{parentName:"em"},"mint.js")," transaction can be called). The Explorer shows these transactions in each new block; be sure to occasionally refresh the Explorer."))),(0,r.kt)("p",null,"Now that the NFT contracts are deployed to both the L1 and the L2, we will register the NFT with the subnet."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-sh"},"node ./register.js\n")),(0,r.kt)("p",null,"This is an L1 transaction so that you can watch for it in the Clarinet interface or the Devnet network on the Explorer."),(0,r.kt)("p",null,"Now, we need an asset to work with, so we will mint an NFT on the L1:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},"node ./mint.js 1\n")),(0,r.kt)("p",null,"We can see this transaction either on the Clarinet interface or in the Devnet network on Explorer."),(0,r.kt)("admonition",{type:"note"},(0,r.kt)("p",{parentName:"admonition"},(0,r.kt)("em",{parentName:"p"},"If you run into problems with any of these transactions, it might be helpful to review the Docker logs from the stacks-node and/or the subnet-node:")),(0,r.kt)("pre",{parentName:"admonition"},(0,r.kt)("code",{parentName:"pre"},"docker logs stacks-node.subnet-nft-example.devnet | less\ndocker logs subnet-node.subnet-nft-example.devnet | less\n"))),(0,r.kt)("p",null,"Once the mint has been processed, we can deposit it into the subnet:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},"node ./deposit.js 2\n")),(0,r.kt)("p",null,"We can see this transaction either on the Clarinet interface or in the Devnet network on the Explorer. Similar to the initial STX deposit that we performed, this deposit will trigger a transfer on the L2, which we can see in the subnet explorer as well. On the subnet, we should see a call to ",(0,r.kt)("inlineCode",{parentName:"p"},"deposit-from-burnchain"),"."),(0,r.kt)("p",null,"We can verify that the NFT is now owned by the subnet contract (",(0,r.kt)("inlineCode",{parentName:"p"},"ST1PQHQKV0RJXZFY1DGX8MNSNYVE3VGZJSRTPGZGM.subnet-v3-0-1"),") on the L1 using:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},"node ./verify.js 1\n")),(0,r.kt)("p",null,"Similarly, we can verify that the NFT is owned by the expected address (",(0,r.kt)("inlineCode",{parentName:"p"},"ST2NEB84ASENDXKYGJPQW86YXQCEFEX2ZQPG87ND"),") on the L2:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},"node ./verify.js 2\n")),(0,r.kt)("p",null,"Now that the NFT is inside the subnet, we can transfer it from one address to another:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},"node ./transfer.js 1\n")),(0,r.kt)("p",null,'We can see this transaction in the "Devnet Subnet" network in our Explorer.'),(0,r.kt)("p",null,"If we call the ",(0,r.kt)("inlineCode",{parentName:"p"},"verify.js")," script again, we should now see that the NFT is owned. by ",(0,r.kt)("inlineCode",{parentName:"p"},"ST2REHHS5J3CERCRBEPMGH7921Q6PYKAADT7JP2VB"),"."),(0,r.kt)("p",null,"Now, we will initiate a withdrawal from the subnet, by calling the ",(0,r.kt)("inlineCode",{parentName:"p"},"nft-withdraw?")," function on the L2 subnet contract."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},"node ./withdraw-l2.js 0\n")),(0,r.kt)("p",null,"We can confirm that this transaction is successful in the L2 explorer."),(0,r.kt)("admonition",{type:"note"},(0,r.kt)("p",{parentName:"admonition"},(0,r.kt)("em",{parentName:"p"},"In the explorer, note the block height that this withdrawal transaction is included in. Fill in this block height for ",(0,r.kt)("inlineCode",{parentName:"em"},"$height")," in the next step."))),(0,r.kt)("p",null,"For the second part of the withdraw, we call ",(0,r.kt)("inlineCode",{parentName:"p"},"withdraw-nft-asset")," on the L1 subnet contract:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-sh"},"node ./withdraw-l1.js $height 1\n")),(0,r.kt)("p",null,"This is an L1 transaction, so it can be confirmed in the L1 explorer or in the Clarinet terminal UI."),(0,r.kt)("p",null,"If everything goes well, now the NFT should be owned by the correct user on the L1 (",(0,r.kt)("inlineCode",{parentName:"p"},"ST2REHHS5J3CERCRBEPMGH7921Q6PYKAADT7JP2VB"),"):"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-sh"},"node ./verify.js 1\n")),(0,r.kt)("p",null,"In the subnet, this asset should not be owned by anyone (",(0,r.kt)("inlineCode",{parentName:"p"},"none"),"):"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-sh"},"node ./verify.js 2\n")))}u.isMDXComponent=!0},17140:(t,e,n)=>{n.d(e,{Z:()=>a});const a=n.p+"assets/images/deposit-stx-53ca3fec4fba566285b9c58f4df81c53.png"},25759:(t,e,n)=>{n.d(e,{Z:()=>a});const a=n.p+"assets/images/subnet-devnet-ae41244eb9d75cbe13a010ff5726a7f8.png"},6215:(t,e,n)=>{n.d(e,{Z:()=>a});const a=n.p+"assets/images/subnets-deployment-confirmed-0fa8f902e69c7fee9159585cdb87f282.png"}}]);