"use strict";(self.webpackChunk_hirosystems_docs=self.webpackChunk_hirosystems_docs||[]).push([[6222],{3905:(t,e,n)=>{n.d(e,{Zo:()=>d,kt:()=>h});var a=n(67294);function r(t,e,n){return e in t?Object.defineProperty(t,e,{value:n,enumerable:!0,configurable:!0,writable:!0}):t[e]=n,t}function o(t,e){var n=Object.keys(t);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(t);e&&(a=a.filter((function(e){return Object.getOwnPropertyDescriptor(t,e).enumerable}))),n.push.apply(n,a)}return n}function i(t){for(var e=1;e<arguments.length;e++){var n=null!=arguments[e]?arguments[e]:{};e%2?o(Object(n),!0).forEach((function(e){r(t,e,n[e])})):Object.getOwnPropertyDescriptors?Object.defineProperties(t,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(e){Object.defineProperty(t,e,Object.getOwnPropertyDescriptor(n,e))}))}return t}function s(t,e){if(null==t)return{};var n,a,r=function(t,e){if(null==t)return{};var n,a,r={},o=Object.keys(t);for(a=0;a<o.length;a++)n=o[a],e.indexOf(n)>=0||(r[n]=t[n]);return r}(t,e);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(t);for(a=0;a<o.length;a++)n=o[a],e.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(t,n)&&(r[n]=t[n])}return r}var l=a.createContext({}),c=function(t){var e=a.useContext(l),n=e;return t&&(n="function"==typeof t?t(e):i(i({},e),t)),n},d=function(t){var e=c(t.components);return a.createElement(l.Provider,{value:e},t.children)},p="mdxType",u={inlineCode:"code",wrapper:function(t){var e=t.children;return a.createElement(a.Fragment,{},e)}},m=a.forwardRef((function(t,e){var n=t.components,r=t.mdxType,o=t.originalType,l=t.parentName,d=s(t,["components","mdxType","originalType","parentName"]),p=c(n),m=r,h=p["".concat(l,".").concat(m)]||p[m]||u[m]||o;return n?a.createElement(h,i(i({ref:e},d),{},{components:n})):a.createElement(h,i({ref:e},d))}));function h(t,e){var n=arguments,r=e&&e.mdxType;if("string"==typeof t||r){var o=n.length,i=new Array(o);i[0]=m;var s={};for(var l in e)hasOwnProperty.call(e,l)&&(s[l]=e[l]);s.originalType=t,s[p]="string"==typeof t?t:r,i[1]=s;for(var c=2;c<o;c++)i[c]=n[c];return a.createElement.apply(null,i)}return a.createElement.apply(null,n)}m.displayName="MDXCreateElement"},87764:(t,e,n)=>{n.r(e),n.d(e,{assets:()=>l,contentTitle:()=>i,default:()=>u,frontMatter:()=>o,metadata:()=>s,toc:()=>c});var a=n(87462),r=(n(67294),n(3905));const o={title:"Transactions"},i="Transactions",s={unversionedId:"stacks-blockchain-api/feature-guides/transactions",id:"stacks-blockchain-api/feature-guides/transactions",title:"Transactions",description:"Transactions are the fundamental unit of execution in the Stacks blockchain. Each transaction is originated from a Stacks account, and is retained in the Stacks blockchain history. This guide helps you understand Stacks transactions.",source:"@site/docs/stacks-blockchain-api/feature-guides/transactions.md",sourceDirName:"stacks-blockchain-api/feature-guides",slug:"/stacks-blockchain-api/feature-guides/transactions",permalink:"/doc/stacks-blockchain-api/feature-guides/transactions",draft:!1,editUrl:"https://github.com/CapybaraIO/doc/tree/main/docs/stacks-blockchain-api/feature-guides/transactions.md",tags:[],version:"current",frontMatter:{title:"Transactions"},sidebar:"stacks-api",previous:{title:"Microblocks",permalink:"/doc/stacks-blockchain-api/feature-guides/microblocks"},next:{title:"Search Endpoint",permalink:"/doc/stacks-blockchain-api/feature-guides/search-endpoint"}},l={},c=[{value:"Lifecycle",id:"lifecycle",level:2},{value:"Types",id:"types",level:2},{value:"Anchor mode",id:"anchor-mode",level:2},{value:"Post-conditions",id:"post-conditions",level:2},{value:"Attributes",id:"attributes",level:3},{value:"Evaluation modes",id:"evaluation-modes",level:3},{value:"Authorization",id:"authorization",level:2},{value:"Encoding",id:"encoding",level:2},{value:"Construction",id:"construction",level:2},{value:"Stacks Token transfer",id:"stacks-token-transfer",level:3},{value:"Smart contract deployment",id:"smart-contract-deployment",level:3},{value:"Smart contract function call",id:"smart-contract-function-call",level:3},{value:"Clarity value types",id:"clarity-value-types",level:3},{value:"Setting post-conditions",id:"setting-post-conditions",level:3},{value:"Serialization",id:"serialization",level:2},{value:"Raw format",id:"raw-format",level:3},{value:"JSON format",id:"json-format",level:3},{value:"Deserializing",id:"deserializing",level:3},{value:"Signature and Verification",id:"signature-and-verification",level:2},{value:"Signing steps",id:"signing-steps",level:3},{value:"Single signature transaction",id:"single-signature-transaction",level:3},{value:"Multi-signature transaction",id:"multi-signature-transaction",level:3},{value:"Sponsored transaction",id:"sponsored-transaction",level:3},{value:"Broadcast",id:"broadcast",level:2},{value:"Mempool",id:"mempool",level:2},{value:"Best practices",id:"best-practices",level:3},{value:"Querying",id:"querying",level:2},{value:"Get recent transactions",id:"get-recent-transactions",level:3},{value:"Get mempool transactions",id:"get-mempool-transactions",level:3},{value:"Filter by type",id:"filter-by-type",level:4},{value:"Get transaction by ID",id:"get-transaction-by-id",level:3},{value:"Garbage Collection",id:"garbage-collection",level:2}],d={toc:c},p="wrapper";function u(t){let{components:e,...n}=t;return(0,r.kt)(p,(0,a.Z)({},d,n,{components:e,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"transactions"},"Transactions"),(0,r.kt)("p",null,"Transactions are the fundamental unit of execution in the Stacks blockchain. Each transaction is originated from a ",(0,r.kt)("a",{parentName:"p",href:"https://docs.stacks.co/understand-stacks/accounts"},"Stacks account"),", and is retained in the Stacks blockchain history. This guide helps you understand Stacks transactions."),(0,r.kt)("h2",{id:"lifecycle"},"Lifecycle"),(0,r.kt)("p",null,"Transactions go through phases before being finally confirmed and propagated on the Stacks network."),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Generate"),": Transactions are assembled according to the encoding specification."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Validate and sign"),": Transactions are validated to confirm they are well-formed. Required signatures are filled in."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Broadcast"),": Transactions are sent to a node."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Register"),": A miner receives transactions, verifies, and adds them to the ",(0,r.kt)("a",{parentName:"li",href:"https://academy.binance.com/en/glossary/mempool"},'"mempool"'),", a holding area for all the pending transactions."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Process"),": Miners review the mempool and select transactions for the next block to be mined. Depending on the transaction type, different actions can happen during this step. For example, post-conditions could be verified for a token transfer, smart-contract defined tokens could be minted, or an attempt to call an existing smart contract method could be made."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Confirm"),": Miners successfully mine blocks, with each block containing a set of transactions. The transactions inside are successfully propagated to the network.")),(0,r.kt)("admonition",{type:"info"},(0,r.kt)("p",{parentName:"admonition"},"A transaction can have one of three states once it is registered: ",(0,r.kt)("inlineCode",{parentName:"p"},"pending"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"success"),", or ",(0,r.kt)("inlineCode",{parentName:"p"},"failed"),".")),(0,r.kt)("h2",{id:"types"},"Types"),(0,r.kt)("p",null,"Stacks supports a set of different transaction types:"),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("strong",{parentName:"th"},"Type")),(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("strong",{parentName:"th"},"Value")),(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("strong",{parentName:"th"},"Description")))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"Coinbase"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"coinbase")),(0,r.kt)("td",{parentName:"tr",align:null},"The first transaction in a new block (an entity holding several transactions). Used to register for block rewards. These are not manually generated and broadcasted like other types of transactions.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"Token transfer"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"token_transfer")),(0,r.kt)("td",{parentName:"tr",align:null},"Asset transfer from a sender to a recipient")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"Contract deploy"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"smart_contract")),(0,r.kt)("td",{parentName:"tr",align:null},"Contract instantiation")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"Contract call"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"contract_call")),(0,r.kt)("td",{parentName:"tr",align:null},"Contract call for a public, non read-only function")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"Poison Microblock"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"poison_microblock")),(0,r.kt)("td",{parentName:"tr",align:null},"Punish leaders who intentionally equivocate about the microblocks they package")))),(0,r.kt)("p",null,"A sample of each transaction type can be found in the ",(0,r.kt)("a",{parentName:"p",href:"https://docs.hiro.so/api#operation/get_transaction_by_id"},"Stacks Blockchain API response definition for transactions"),"."),(0,r.kt)("p",null,"~> Read-only contract call calls do ",(0,r.kt)("strong",{parentName:"p"},"not")," require transactions. Read more about it in the ",(0,r.kt)("a",{parentName:"p",href:"https://docs.stacks.co/understand-stacks/network#read-only-function-calls"},"network guide"),"."),(0,r.kt)("h2",{id:"anchor-mode"},"Anchor mode"),(0,r.kt)("p",null,"Transactions can be mined either in an anchor block or in a ",(0,r.kt)("a",{parentName:"p",href:"https://docs.stacks.co/understand-stacks/microblocks"},"microblock"),". If microblocks\nare selected, the transaction can be confirmed with a lower latency than the anchor block time."),(0,r.kt)("p",null,"The anchor mode enum has three options:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"OnChainOnly")," The transaction MUST be included in an anchored block"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"OffChainOnly"),": The transaction MUST be included in a microblock"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"Any"),": The leader can choose where to include the transaction")),(0,r.kt)("p",null,"Here is an example where the transaction must be included in a microblock:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},'import { AnchorMode, makeSTXTokenTransfer } from "@stacks/transactions";\nimport { StacksTestnet, StacksMainnet } from "@stacks/network";\n\nconst BigNum = require("bn.js");\n\nconst txOptions = {\n  recipient: "SP3FGQ8Z7JY9BWYZ5WM53E0M9NK7WHJF0691NZ159",\n  amount: new BigNum(12345),\n  senderKey:\n    "b244296d5907de9864c0b0d51f98a13c52890be0404e83f273144cd5b9960eed01",\n  network: new StacksTestnet(), // for mainnet, use `StacksMainnet()`\n  anchorMode: AnchorMode.OffChainOnly, // must be included in a microblock\n};\n\nconst transaction = await makeSTXTokenTransfer(txOptions);\n')),(0,r.kt)("h2",{id:"post-conditions"},"Post-conditions"),(0,r.kt)("p",null,"Transaction post-conditions are a feature meant to limit the damage malicious smart contract developers and smart contract bugs can do in terms of destroying a user's assets. Post-conditions are executed whenever a contract is instantiated or a public method of an existing contract is executed. Whenever a post-condition fails, a transaction will be forced to abort."),(0,r.kt)("p",null,"Post-conditions are meant to be added by the user (or by the user's wallet software) at the moment they sign a transaction. For example, a user may append a post-condition saying that upon successful execution, their account's Stacks (STX) balance should have decreased by no more than 1 STX. If this is not the case, then the transaction would abort and the account would only pay the transaction fee of processing it."),(0,r.kt)("h3",{id:"attributes"},"Attributes"),(0,r.kt)("p",null,"Each transaction includes a field that describes zero or more post-conditions that must all be true when the transaction finishes running. The post-condition describes only properties of the owner of the asset before the transaction happened. For a transfer transaction, the post-condition is about the sender, for a burn transaction, the post-condition is about the previous owner. A post-condition includes the following information:"),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("strong",{parentName:"th"},"Attribute")),(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("strong",{parentName:"th"},"Sample")),(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("strong",{parentName:"th"},"Description")))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("a",{parentName:"td",href:"https://docs.stacks.co/write-smart-contracts/principals"},"Principal")),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"SP2ZD731ANQZT6J4K3F5N8A40ZXWXC1XFXHVVQFKE")),(0,r.kt)("td",{parentName:"tr",align:null},"Original owner of the asset, can be a Stacks address or a contract")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"Asset id"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"STX")),(0,r.kt)("td",{parentName:"tr",align:null},"Asset to apply conditions to (could be STX, fungible, or non-fungible tokens)")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"Comparator"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},">=")),(0,r.kt)("td",{parentName:"tr",align:null},'Compare operation to be applied (could define "how much" or "whether or not the asset is owned")')),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"Literal"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"1000000")),(0,r.kt)("td",{parentName:"tr",align:null},"Integer or boolean value used to compare instances of the asset against via the condition")))),(0,r.kt)("h3",{id:"evaluation-modes"},"Evaluation modes"),(0,r.kt)("p",null,"The Stacks blockchain supports an ",(0,r.kt)("inlineCode",{parentName:"p"},"allow")," or ",(0,r.kt)("inlineCode",{parentName:"p"},"deny")," mode for evaluating post-conditions:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Allow: other asset transfers not covered by the post-conditions are permitted"),(0,r.kt)("li",{parentName:"ul"},"Deny: no other asset transfers are permitted besides those named in the post-conditions")),(0,r.kt)("h2",{id:"authorization"},"Authorization"),(0,r.kt)("p",null,"Transactions can be authorized in two ways: ",(0,r.kt)("em",{parentName:"p"},"standard")," and ",(0,r.kt)("em",{parentName:"p"},"sponsored"),". The authorization determines whether or not the originating account is also the paying account. In a transaction with a standard authorization, the origin and paying accounts are the same. In a transaction with a sponsored authorization, the origin and paying accounts are distinct, and both accounts must sign the transaction for it to be valid (first the origin, then the spender)."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Sponsored transactions")," enable developers and/or infrastructure operators to pay for users to call into their smart contracts, even if users do not have the Stacks (STX) to do so."),(0,r.kt)("p",null,"The signing flow for sponsored transactions would be to have the user first sign the transaction with their origin account with the intent of it being sponsored (that is, the user must explicitly allow a sponsor to sign), and then have the sponsor sign with their paying account to pay for the user's transaction fee."),(0,r.kt)("h2",{id:"encoding"},"Encoding"),(0,r.kt)("p",null,"A transaction includes the following information. Multiple-byte fields are encoded as big-endian."),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("strong",{parentName:"th"},"Type")),(0,r.kt)("th",{parentName:"tr",align:null},(0,r.kt)("strong",{parentName:"th"},"Description")))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"Version number"),(0,r.kt)("td",{parentName:"tr",align:null},"Network version. ",(0,r.kt)("inlineCode",{parentName:"td"},"0x80")," for testnet, ",(0,r.kt)("inlineCode",{parentName:"td"},"0x0")," for mainnet")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"Chain ID"),(0,r.kt)("td",{parentName:"tr",align:null},"Chain instance ID. ",(0,r.kt)("inlineCode",{parentName:"td"},"0x80000000")," for testnet, ",(0,r.kt)("inlineCode",{parentName:"td"},"0x00000001")," for mainnet")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"Authorization"),(0,r.kt)("td",{parentName:"tr",align:null},"Type of authorization (",(0,r.kt)("inlineCode",{parentName:"td"},"0x04")," for standard, ",(0,r.kt)("inlineCode",{parentName:"td"},"0x05")," for sponsored) and ",(0,r.kt)("a",{parentName:"td",href:"https://github.com/stacksgov/sips/blob/main/sips/sip-005/sip-005-blocks-and-transactions.md#transaction-authorization"},"spending conditions"))),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"Post-conditions"),(0,r.kt)("td",{parentName:"tr",align:null},"List of post-conditions, each including a ",(0,r.kt)("a",{parentName:"td",href:"https://github.com/stacksgov/sips/blob/main/sips/sip-005/sip-005-blocks-and-transactions.md#transaction-post-conditions-1"},"type ID and variable-length condition body"))),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"Payload"),(0,r.kt)("td",{parentName:"tr",align:null},"Transaction type and variable-length ",(0,r.kt)("a",{parentName:"td",href:"https://github.com/stacksgov/sips/blob/main/sips/sip-005/sip-005-blocks-and-transactions.md#transaction-payloads-1"},"payload"))))),(0,r.kt)("h2",{id:"construction"},"Construction"),(0,r.kt)("p",null,"The easiest way to construct well-formed transactions is by ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/blockstack/stacks.js/tree/master/packages/transactions#post-conditions"},"using the Stacks Transactions JS library"),". You can construct the following transaction types:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Stacks token transfer"),(0,r.kt)("li",{parentName:"ul"},"Smart contract deploy"),(0,r.kt)("li",{parentName:"ul"},"Smart contract function call")),(0,r.kt)("p",null,"When constructing transactions, it is required to set the network the transaction is intended for. This can be either mainnet or testnet. At the moment of this writing, the only available option is the ",(0,r.kt)("a",{parentName:"p",href:"https://docs.stacks.co/understand-stacks/testnet"},"testnet network"),"."),(0,r.kt)("admonition",{type:"info"},(0,r.kt)("p",{parentName:"admonition"},"Transactions can be constructed and serialized offline. However, it is required to know the nonce and estimated fees ahead of time. Once internet access is available, the transaction can be broadcast to the network. Keep in mind that the nonce and fee might change during offline activity, making the transaction invalid.")),(0,r.kt)("h3",{id:"stacks-token-transfer"},"Stacks Token transfer"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},'import { makeSTXTokenTransfer } from "@stacks/transactions";\nimport { StacksTestnet, StacksMainnet } from "@stacks/network";\n\nconst BigNum = require("bn.js");\n\nconst txOptions = {\n  recipient: "SP3FGQ8Z7JY9BWYZ5WM53E0M9NK7WHJF0691NZ159",\n  amount: new BigNum(12345),\n  senderKey:\n    "b244296d5907de9864c0b0d51f98a13c52890be0404e83f273144cd5b9960eed01",\n  network: new StacksTestnet(), // for mainnet, use `StacksMainnet()`\n  memo: "test memo",\n  nonce: new BigNum(0), // set a nonce manually if you don\'t want builder to fetch from a Stacks node\n  fee: new BigNum(200), // set a tx fee if you don\'t want the builder to estimate\n};\n\nconst transaction = await makeSTXTokenTransfer(txOptions);\n')),(0,r.kt)("admonition",{type:"info"},(0,r.kt)("p",{parentName:"admonition"},"Read more about ",(0,r.kt)("a",{parentName:"p",href:"http://docs.stacks.co/understand-stacks/network#nonces"},"nonces")," in the network guide")),(0,r.kt)("h3",{id:"smart-contract-deployment"},"Smart contract deployment"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},'import { makeContractDeploy } from "@stacks/transactions";\nimport { StacksTestnet, StacksMainnet } from "@stacks/network";\nconst BigNum = require("bn.js");\n\nconst txOptions = {\n  contractName: "contract_name",\n  codeBody: fs.readFileSync("/path/to/contract.clar").toString(),\n  senderKey:\n    "b244296d5907de9864c0b0d51f98a13c52890be0404e83f273144cd5b9960eed01",\n  network: new StacksTestnet(), // for mainnet, use `StacksMainnet()`\n};\n\nconst transaction = await makeContractDeploy(txOptions);\n')),(0,r.kt)("h3",{id:"smart-contract-function-call"},"Smart contract function call"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},'import { makeContractCall, BufferCV } from "@stacks/transactions";\nimport { StacksTestnet, StacksMainnet } from "@stacks/network";\n\nconst BigNum = require("bn.js");\n\nconst txOptions = {\n  contractAddress: "SPBMRFRPPGCDE3F384WCJPK8PQJGZ8K9QKK7F59X",\n  contractName: "contract_name",\n  functionName: "contract_function",\n  functionArgs: [bufferCVFromString("foo")],\n  senderKey:\n    "b244296d5907de9864c0b0d51f98a13c52890be0404e83f273144cd5b9960eed01",\n  // attempt to fetch this contracts interface and validate the provided functionArgs\n  validateWithAbi: true,\n  network: new StacksTestnet(), // for mainnet, use `StacksMainnet()`\n};\n\nconst transaction = await makeContractCall(txOptions);\n')),(0,r.kt)("h3",{id:"clarity-value-types"},"Clarity value types"),(0,r.kt)("p",null,"Building transactions that call functions in deployed clarity contracts requires you to construct valid Clarity values to pass to the function as arguments. The ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/stacksgov/sips/blob/main/sips/sip-002/sip-002-smart-contract-language.md#clarity-type-system"},"Clarity type system")," contains the following types:"),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"Type"),(0,r.kt)("th",{parentName:"tr",align:null},"Declaration"),(0,r.kt)("th",{parentName:"tr",align:null},"Description"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"Tuple"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"(tuple (key-name-0 key-type-0) ...)")),(0,r.kt)("td",{parentName:"tr",align:null},"Typed tuple with named fields")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"List"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"(list max-len entry-type)")),(0,r.kt)("td",{parentName:"tr",align:null},"List of maximum length max-len, with entries of type entry-type")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"Response"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"(response ok-type err-type)")),(0,r.kt)("td",{parentName:"tr",align:null},"Object used by public functions to commit their changes or abort. May be returned or used by other functions as well, however, only public functions have the commit/abort behavior")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"Optional"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"(optional some-type)")),(0,r.kt)("td",{parentName:"tr",align:null},"Option type for objects that can either be (some value) or none")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"Buffer"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"(buff max-len)")),(0,r.kt)("td",{parentName:"tr",align:null},"Byte buffer with maximum length ",(0,r.kt)("inlineCode",{parentName:"td"},"max-len"))),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"Principal"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"principal")),(0,r.kt)("td",{parentName:"tr",align:null},"Object representing a principal (whether a contract principal or standard principal)")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"Boolean"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"bool")),(0,r.kt)("td",{parentName:"tr",align:null},"Boolean value ('true or 'false)")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"Signed Integer"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"int")),(0,r.kt)("td",{parentName:"tr",align:null},"Signed 128-bit integer")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"Unsigned Integer"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"uint")),(0,r.kt)("td",{parentName:"tr",align:null},"Unsigned 128-bit integer")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"ASCII String"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},'(define-data-var my-str (string-ascii 11) "hello world")')),(0,r.kt)("td",{parentName:"tr",align:null},"String value encoded in ASCII")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"UTF-8 String"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},'(define-data-var my-str (string-utf8 7) u"hello \\u{1234}")')),(0,r.kt)("td",{parentName:"tr",align:null},"String value encoded in UTF-8")))),(0,r.kt)("p",null,"The Stacks Transactions JS library contains TypeScript types and classes that map to the Clarity types, in order to make it easy to construct well-typed Clarity values in JavaScript. These types all extend the abstract class ",(0,r.kt)("inlineCode",{parentName:"p"},"ClarityValue"),"."),(0,r.kt)("p",null,"Here are samples for Clarity value constructions using this library:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},'// construct boolean clarity values\nconst t = trueCV();\nconst f = falseCV();\n\n// construct optional clarity values\nconst nothing = noneCV();\nconst something = someCV(t);\n\n// construct a buffer clarity value from an existing Buffer\nconst buffer = Buffer.from("foo");\nconst bufCV = bufferCV(buffer);\n\n// construct signed and unsigned integer clarity values\nconst i = intCV(-10);\nconst u = uintCV(10);\n\n// construct principal clarity values\nconst address = "SP2JXKMSH007NPYAQHKJPQMAQYAD90NQGTVJVQ02B";\nconst contractName = "contract-name";\nconst spCV = standardPrincipalCV(address);\nconst cpCV = contractPrincipalCV(address, contractName);\n\n// construct response clarity values\nconst errCV = responseErrorCV(trueCV());\nconst okCV = responseOkCV(falseCV());\n\n// construct tuple clarity values\nconst tupCV = tupleCV({\n  a: intCV(1),\n  b: trueCV(),\n  c: falseCV(),\n});\n\n// construct list clarity values\nconst l = listCV([trueCV(), falseCV()]);\n')),(0,r.kt)("p",null,"If you develop in Typescript, the type checker can help prevent you from creating wrongly-typed Clarity values. For example, the following code won't compile since lists are homogeneous in Clarity, meaning they can only contain values of a single type. It is important to include the type variable ",(0,r.kt)("inlineCode",{parentName:"p"},"BooleanCV")," in this example; otherwise the typescript type checker won't know which type the list is of and won't enforce homogeneity."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},"const l = listCV < BooleanCV > [trueCV(), intCV(1)];\n")),(0,r.kt)("h3",{id:"setting-post-conditions"},"Setting post-conditions"),(0,r.kt)("p",null,"The Stacks Transactions JS library supports the construction of post conditions."),(0,r.kt)("p",null,"Here is an example of a post condition that ensures the account's balance will only decrease by no more than 1 STX:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},"const account = 'SP2ZD731ANQZT6J4K3F5N8A40ZXWXC1XFXHVVQFKE';\nconst comparator = FungibleConditionCode.GreaterEqual;\n// assuming the Stacks (STX) balance before the transaction is 12346\nconst amount = new BigNum(12345);\n\nconst standardSTXPostCondition = makeStandardSTXPostCondition(\n  account,\n  comparator,\n  amount\n);\n\nconst txOptions = {\n  ..., // other transaction options\n  postConditions: [standardSTXPostCondition]\n}\n\nconst transaction = await makeContractCall(txOptions);\n")),(0,r.kt)("h2",{id:"serialization"},"Serialization"),(0,r.kt)("p",null,"A well-formed transaction construct is encoded in ",(0,r.kt)("a",{parentName:"p",href:"https://eth.wiki/en/fundamentals/rlp"},'Recursive Length Prefix ("RLP")'),". RLP encoding results in a variable-sized byte array."),(0,r.kt)("p",null,"In order to broadcast transactions to and between nodes on the network, RLP data is represented in hexadecimal string (also called the ",(0,r.kt)("strong",{parentName:"p"},"raw format"),")."),(0,r.kt)("p",null,"To support an API-friendly and human-readable representation, the ",(0,r.kt)("a",{parentName:"p",href:"/get-started/stacks-blockchain-api"},"Stacks Blockchain API")," converts transactions into a JSON format."),(0,r.kt)("p",null,"=> ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/blockstack/stacks.js"},"The Stacks Transactions JS library")," supports serialization of transactions."),(0,r.kt)("h3",{id:"raw-format"},"Raw format"),(0,r.kt)("p",null,"Broadcasting transactions directly to the Stacks Blockchain API or Node RPC API requires the transaction to be serialized and in hexadecimal representation."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},'// to see the raw serialized tx\nconst serializedTx = transaction.serialize().toString("hex");\n\nconsole.log(serializedTx);\n')),(0,r.kt)("p",null,"The preceding method returns the following string:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-bash"},"8080000000040015c31b8c1c11c515e244b75806bac48d1399c77500000000000000000000000000000000000127e88a68dce8689fc94ff4c186bf8966f8d544c5129ff84d95a2459b5e8e7c39430388f6c8f85cce8c9ce5e6ec1e157116ca4a67d65ab53768b25d5fb5831939030200000000000516df0ba3e79792be7be5e50a370289accfc8c9e03200000000000f424068656c6c6f20776f726c640000000000000000000000000000000000000000000000\n")),(0,r.kt)("p",null,"-> Transaction IDs are generated by hashing the raw transaction with ",(0,r.kt)("a",{parentName:"p",href:"https://eprint.iacr.org/2010/548.pdf"},"sha512/256")),(0,r.kt)("h3",{id:"json-format"},"JSON format"),(0,r.kt)("p",null,"When called the Stacks Blockchain API or Node RPC API, transactions returned will be serialized in a JSON format. Here is a token transfer transaction:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},'{\n  "tx_id": "0x77cb1bf0804f09ad24b4c494a6c00d5b10bb0afbb94a0d646fa9640eff338e37",\n  "nonce": 5893,\n  "fee_rate": "180",\n  "sender_address": "STB44HYPYAT2BB2QE513NSP81HTMYWBJP02HPGK6",\n  "sponsored": false,\n  "post_condition_mode": "deny",\n  "post_conditions": [],\n  "anchor_mode": "any",\n  "block_hash": "0xf1e54a3acd04232f1362c09d5096b095363158348303396ea5fc5092e1d8788f",\n  "parent_block_hash": "0x3de356eb5afa5d7b781f6a925d31d69d218b772ec995930b4e15d92bd15443f9",\n  "block_height": 13984,\n  "burn_block_time": 1622678407,\n  "burn_block_time_iso": "2021-06-03T00:00:07.000Z",\n  "canonical": true,\n  "tx_index": 2,\n  "tx_status": "success",\n  "tx_result": {\n    "hex": "0x0703",\n    "repr": "(ok true)"\n  },\n  "microblock_hash": "",\n  "microblock_sequence": 2147483647,\n  "microblock_canonical": true,\n  "event_count": 1,\n  "events": [],\n  "tx_type": "token_transfer",\n  "token_transfer": {\n    "recipient_address": "STZ4C5RT4WH4JGRQA5E0ZF5PPSQCVY1WRB6E2CGW",\n    "amount": "500000000",\n    "memo": "0x46617563657400000000000000000000000000000000000000000000000000000000"\n  }\n}\n')),(0,r.kt)("h3",{id:"deserializing"},"Deserializing"),(0,r.kt)("p",null,"Serialized, raw transactions can be deserialized without access to the internet using ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/blockstack/stacks.js/tree/master/packages/transactions"},"the Stacks Transactions JS library"),":"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},'import { BufferReader, deserializeTransaction } from "@stacks/transactions";\n\n// receive raw transaction\nconst serializedTx = "808000000...";\n\nconst bufferReader = new BufferReader(Buffer.from(serializedTx));\nconst deserializedTx = deserializeTransaction(bufferReader);\n\n// print memo\nconsole.log(deserializedTx.payload.memo.content);\n')),(0,r.kt)("h2",{id:"signature-and-verification"},"Signature and Verification"),(0,r.kt)("p",null,"Every transaction contains verifiable signatures that certify its authenticity. These signatures are generated by signing the transaction hash with the origin's private key. The Elliptic Curve Digital Signature Algorithm (ECDSA) is used for signing, with the curve set to secp256k1. The internal structure that encapsulates the signature is the spending condition. Spending conditions include several parameters including the public key hash, nonce, fee rate and the recoverable ECDSA signature."),(0,r.kt)("p",null,"When constructing a transaction using the JS library, you can supply the private key and signing will be completed automatically. If you would like to sign the transaction manually, use the ",(0,r.kt)("inlineCode",{parentName:"p"},"TransactionSigner")," class."),(0,r.kt)("p",null,"Below are the steps taken to generate the signature internal to the transaction library."),(0,r.kt)("h3",{id:"signing-steps"},"Signing steps"),(0,r.kt)("p",null,"1: Generate a transaction hash for signing. This is the SHA512/256 digest of the serialized transaction before a signature is added.\n2: Append the authorization type, fee amount and nonce to the transaction hash to create the signature hash.\n3: Generate the SHA512/256 hash of the resulting string from the previous step.\n4: Sign the hash using ECDSA and the origin private key.\n5: Add the resulting recoverable ECDSA signature to the transaction spending condition."),(0,r.kt)("h3",{id:"single-signature-transaction"},"Single signature transaction"),(0,r.kt)("p",null,"As the name implies a single signature transaction contains 1 signature from the origin account that authorizes a token spend or smart contract deploy/execution."),(0,r.kt)("h3",{id:"multi-signature-transaction"},"Multi-signature transaction"),(0,r.kt)("p",null,"For multi-sig accounts, multiple keys must sign the transaction for it to be valid."),(0,r.kt)("h3",{id:"sponsored-transaction"},"Sponsored transaction"),(0,r.kt)("p",null,"A sponsored transaction is one where a second signer sets and pays the transaction fees. The origin must sign the transaction first before the sponsor signs."),(0,r.kt)("h2",{id:"broadcast"},"Broadcast"),(0,r.kt)("p",null,"With a serialized transaction in the ",(0,r.kt)("a",{parentName:"p",href:"#raw-format"},"raw format"),", it can be broadcast to the network using the ",(0,r.kt)("a",{parentName:"p",href:"https://docs.hiro.so/api#operation/post_core_node_transactions"},(0,r.kt)("inlineCode",{parentName:"a"},"POST /v2/transactions"))," endpoint:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-bash"},"# for mainnet, replace `testnet` with `mainnet`\ncurl --location --request POST 'https://api.testnet.hiro.so/v2/transactions' \\\n--header 'Content-Type: application/octet-stream' \\\n--data-raw '<tx_raw_format>'\n")),(0,r.kt)("p",null,"The API will respond with a ",(0,r.kt)("inlineCode",{parentName:"p"},"HTTP 200 - OK")," if the transaction was successfully added to the mempool."),(0,r.kt)("p",null,"There is no explicit time constraint between the construction of a valid signed transaction and when it can be broadcast. There are, however, some constraints to be aware of. The following reasons can deem a transaction invalid after some period:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Token transfer: Nonce changed in-between construction and broadcast"),(0,r.kt)("li",{parentName:"ul"},"Contract call or deploy: Block height is evaluated (with ",(0,r.kt)("a",{parentName:"li",href:"https://docs.stacks.co/references/language-functions#at-block"},(0,r.kt)("inlineCode",{parentName:"a"},"at-block")),") and changed in-between construction and broadcast")),(0,r.kt)("h2",{id:"mempool"},"Mempool"),(0,r.kt)("p",null,"Once a transaction has been successfully broadcast to the network, the transaction is added to the mempool of the node\nthat received the broadcast. From the ",(0,r.kt)("a",{parentName:"p",href:"https://en.bitcoin.it/wiki/Vocabulary#Memory_pool"},"Bitcoin wiki"),': "a node\'s memory pool contains all 0-confirmation transactions\nacross the entire network that that particular node knows about."'),(0,r.kt)("p",null,"So, the set of transactions in the mempool might be\ndifferent for each node in the network. For example, when you query the mempool endpoints on\n",(0,r.kt)("inlineCode",{parentName:"p"},"api.mainnet.hiro.so"),", the response reflects the set of unconfirmed transactions known to the nodes that\nservice that API."),(0,r.kt)("p",null,"Miners can employ different heuristics and strategies for deciding which transactions to admit into the mempool and\nwhich transactions to include from the mempool when mining a block. Some transactions may be rejected outright (for\nexample, if there are insufficient funds at an address) while others might be accepted into the mempool, but not mined\ninto a block indefinitely (for example if fees are too low)."),(0,r.kt)("p",null,'Transactions that are admitted in the mempool but not yet\nmined are said to be "pending." The current implementation of ',(0,r.kt)("a",{parentName:"p",href:"https://github.com/blockstack/stacks-blockchain"},"stacks-blockchain")," discards pending mempool\ntransactions after ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/blockstack/stacks-blockchain/blob/master/src/core/mempool.rs#L59"},"256 blocks"),"."),(0,r.kt)("h3",{id:"best-practices"},"Best practices"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Nonce:")," it's crucial that transactions use the correct nonce. Using an incorrect nonce makes it less likely that\nthe transaction is mined in a timely manner. To determine the correct nonce, query the ",(0,r.kt)("a",{parentName:"li",href:"https://docs.stacks.co/understand-stacks/accounts#get-stacks-stx-balance-and-nonce"},(0,r.kt)("inlineCode",{parentName:"a"},"accounts"))," endpoint of\nthe node you intend to broadcast your transaction to. The value of the ",(0,r.kt)("inlineCode",{parentName:"li"},"nonce")," field of the response is the next nonce\nthat the node expects to consume for that account. Nonce starts at ",(0,r.kt)("inlineCode",{parentName:"li"},"0"),", so the first transaction from an account should\nbe set to ",(0,r.kt)("inlineCode",{parentName:"li"},"nonce=0"),"."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Transaction chaining:")," even when using the correct nonce, transactions might arrive at a node out-of-order. For\ninstance, a transaction with ",(0,r.kt)("inlineCode",{parentName:"li"},"nonce=1")," may arrive in the mempool before the ",(0,r.kt)("inlineCode",{parentName:"li"},"nonce=0")," transaction. Stacks nodes admit\nsuch out-of-order transactions in the mempool, but only up to a limit (",(0,r.kt)("a",{parentName:"li",href:"https://github.com/blockstack/stacks-blockchain/blob/08c4b9d61b48b99475c0197e7e7fea50c7fb0e29/src/core/mempool.rs#L66"},"25 in the current implementation"),"). So, you\nshould limit any chain of unconfirmed transactions from a single account to less than 25. Making this limit higher has\ndownsides, discussed in ",(0,r.kt)("a",{parentName:"li",href:"https://github.com/blockstack/stacks-blockchain/issues/2384"},"this issue"),". If you need to send\nmore than 25 transactions per block, consider using multiple accounts or a smart-contract based approach. See\n",(0,r.kt)("a",{parentName:"li",href:"https://www.npmjs.com/package/@stacks/send-many-stx-cli"},"this tool"),", for example, that allows up to 200 token\ntransfers in a single transaction.")),(0,r.kt)("h2",{id:"querying"},"Querying"),(0,r.kt)("p",null,"Transactions on the Stacks 2.0 network can be queried using the ",(0,r.kt)("a",{parentName:"p",href:"/get-started/stacks-blockchain-api"},"Stacks Blockchain API"),". The API exposes two interfaces, a RESTful JSON API and a WebSockets API."),(0,r.kt)("p",null,"For convenience, a Postman Collection was created and published: ",(0,r.kt)("a",{parentName:"p",href:"https://app.getpostman.com/run-collection/614feab5c108d292bffa"},(0,r.kt)("img",{parentName:"a",src:"https://run.pstmn.io/button.svg",alt:"Run in Postman"}))),(0,r.kt)("p",null,"-> Note: The API can be easily consumed using a generated ",(0,r.kt)("a",{parentName:"p",href:"https://hirosystems.github.io/stacks-blockchain-api/client/index.html"},"JS client library"),". The generator uses an OpenAPI specification and supports other languages and frameworks."),(0,r.kt)("p",null,'@include "stacks-api-pagination.md"'),(0,r.kt)("h3",{id:"get-recent-transactions"},"Get recent transactions"),(0,r.kt)("p",null,"Recent transactions can be obtained through the ",(0,r.kt)("a",{parentName:"p",href:"https://docs.hiro.so/api#operation/get_transaction_list"},(0,r.kt)("inlineCode",{parentName:"a"},"GET /extended/v1/tx"))," endpoint:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-bash"},"# for mainnet, replace `testnet` with `mainnet`\ncurl 'https://api.testnet.hiro.so/extended/v1/tx'\n")),(0,r.kt)("p",null,"Sample response:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},'{\n  "limit": 10,\n  "offset": 0,\n  "total": 101922,\n  "results": [\n    {\n      "tx_id": "0x5e9f3933e358df6a73fec0d47ce3e1062c20812c129f5294e6f37a8d27c051d9",\n      "tx_status": "success",\n      "tx_type": "coinbase",\n      "fee_rate": "0",\n      "sender_address": "ST3WCQ6S0DFT7YHF53M8JPKGDS1N1GSSR91677XF1",\n      "sponsored": false,\n      "post_condition_mode": "deny",\n      "block_hash": "0x58412b50266debd0c35b1a20348ad9c0f17e5525fb155a97033256c83c9e2491",\n      "block_height": 3231,\n      "burn_block_time": 1594230455,\n      "canonical": true,\n      "tx_index": 0,\n      "coinbase_payload": {\n        "data": "0x0000000000000000000000000000000000000000000000000000000000000000"\n      }\n    }\n  ]\n}\n')),(0,r.kt)("h3",{id:"get-mempool-transactions"},"Get mempool transactions"),(0,r.kt)("p",null,"Mempool (registered, but not processed) transactions can be obtained using the ",(0,r.kt)("a",{parentName:"p",href:"https://docs.hiro.so/api#operation/get_mempool_transaction_list"},(0,r.kt)("inlineCode",{parentName:"a"},"GET /extended/v1/tx/mempool"))," endpoint:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-bash"},"# for mainnet, replace `testnet` with `mainnet`\ncurl 'https://api.testnet.hiro.so/extended/v1/tx/mempool'\n")),(0,r.kt)("p",null,"Sample response:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},'{\n  "limit": 96,\n  "offset": 0,\n  "total": 5,\n  "results": [\n    {\n      "tx_id": "0xb31df5a363dad31723324cb5e0eefa04d491519fd30827a521cbc830114aa50c",\n      "tx_status": "pending",\n      "tx_type": "token_transfer",\n      "receipt_time": 1598288370,\n      "receipt_time_iso": "2020-08-24T16:59:30.000Z",\n      "fee_rate": "180",\n      "sender_address": "STB44HYPYAT2BB2QE513NSP81HTMYWBJP02HPGK6",\n      "sponsored": false,\n      "post_condition_mode": "deny",\n      "token_transfer": {\n        "recipient_address": "ST1GY25DM8RZV4X15X07THRZ2C5NMWPGQWKFGV87F",\n        "amount": "500000",\n        "memo": "0x46617563657400000000000000000000000000000000000000000000000000000000"\n      }\n    }\n  ]\n}\n')),(0,r.kt)("p",null,"-> The ",(0,r.kt)("inlineCode",{parentName:"p"},"memo")," field is represented as a hexadecimal string of a byte buffer"),(0,r.kt)("h4",{id:"filter-by-type"},"Filter by type"),(0,r.kt)("p",null,"Recent transactions can be filtered by ",(0,r.kt)("a",{parentName:"p",href:"#types"},"transaction type")," using the ",(0,r.kt)("inlineCode",{parentName:"p"},"type")," query parameter:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-bash"},"# for mainnet, replace `testnet` with `mainnet`\ncurl 'https://api.testnet.hiro.so/extended/v1/tx/?type=contract_call'\n")),(0,r.kt)("h3",{id:"get-transaction-by-id"},"Get transaction by ID"),(0,r.kt)("p",null,"A specific transaction can be obtained using the ",(0,r.kt)("a",{parentName:"p",href:"https://docs.hiro.so/api#operation/get_transaction_by_id"},(0,r.kt)("inlineCode",{parentName:"a"},"GET /extended/v1/tx/<tx_id>"))," endpoint:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-bash"},"# for mainnet, replace `testnet` with `mainnet`\ncurl 'https://api.testnet.hiro.so/extended/v1/tx/<tx_id>'\n")),(0,r.kt)("p",null,"Sample response:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},'{\n  "limit": 96,\n  "offset": 0,\n  "total": 5,\n  "results": [\n    {\n      "tx_id": "0xb31df5a363dad31723324cb5e0eefa04d491519fd30827a521cbc830114aa50c",\n      "tx_status": "pending",\n      "tx_type": "token_transfer",\n      "receipt_time": 1598288370,\n      "receipt_time_iso": "2020-08-24T16:59:30.000Z",\n      "fee_rate": "180",\n      "sender_address": "STB44HYPYAT2BB2QE513NSP81HTMYWBJP02HPGK6",\n      "sponsored": false,\n      "post_condition_mode": "deny",\n      "token_transfer": {\n        "recipient_address": "ST1GY25DM8RZV4X15X07THRZ2C5NMWPGQWKFGV87F",\n        "amount": "500000",\n        "memo": "0x46617563657400000000000000000000000000000000000000000000000000000000"\n      }\n    }\n  ]\n}\n')),(0,r.kt)("h2",{id:"garbage-collection"},"Garbage Collection"),(0,r.kt)("p",null,"Broadcast transactions stay in the mempool for 256 blocks (~42 hours). If a transaction is not confirmed within that time, it is removed from the mempool."),(0,r.kt)("p",null,"Most transactions stay in the mempool due to nonce issues. If you see a transaction pending for an unusual time, review the nonce of the account and the transaction."),(0,r.kt)("p",null,"If a transaction is removed from the mempool, the transaction was not processed and no changes were made to the blockchain state."))}u.isMDXComponent=!0}}]);