"use strict";(self.webpackChunk_CapybaraIO_docs=self.webpackChunk_CapybaraIO_docs||[]).push([[6455],{3905:(e,t,n)=>{n.d(t,{Zo:()=>u,kt:()=>k});var a=n(67294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function l(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},i=Object.keys(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var o=a.createContext({}),c=function(e){var t=a.useContext(o),n=t;return e&&(n="function"==typeof e?e(t):l(l({},t),e)),n},u=function(e){var t=c(e.components);return a.createElement(o.Provider,{value:t},e.children)},p="mdxType",h={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},d=a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,i=e.originalType,o=e.parentName,u=s(e,["components","mdxType","originalType","parentName"]),p=c(n),d=r,k=p["".concat(o,".").concat(d)]||p[d]||h[d]||i;return n?a.createElement(k,l(l({ref:t},u),{},{components:n})):a.createElement(k,l({ref:t},u))}));function k(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var i=n.length,l=new Array(i);l[0]=d;var s={};for(var o in t)hasOwnProperty.call(t,o)&&(s[o]=t[o]);s.originalType=e,s[p]="string"==typeof e?e:r,l[1]=s;for(var c=2;c<i;c++)l[c]=n[c];return a.createElement.apply(null,l)}return a.createElement.apply(null,n)}d.displayName="MDXCreateElement"},51938:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>o,contentTitle:()=>l,default:()=>h,frontMatter:()=>i,metadata:()=>s,toc:()=>c});var a=n(87462),r=(n(67294),n(3905));const i={title:"Analyze with Check-Checker"},l=void 0,s={unversionedId:"clarinet/guides/analyze-with-check-checker",id:"clarinet/guides/analyze-with-check-checker",title:"Analyze with Check-Checker",description:"The check-checker is a static analysis pass you can use to help find potential vulnerabilities in your contracts.",source:"@site/docs/clarinet/guides/analyze-with-check-checker.md",sourceDirName:"clarinet/guides",slug:"/clarinet/guides/analyze-with-check-checker",permalink:"/doc/clarinet/guides/analyze-with-check-checker",draft:!1,editUrl:"https://github.com/CapybaraIO/doc/tree/main/docs/clarinet/guides/analyze-with-check-checker.md",tags:[],version:"current",lastUpdatedAt:1703206175,formattedLastUpdatedAt:"Dec 22, 2023",frontMatter:{title:"Analyze with Check-Checker"},sidebar:"clarinet",previous:{title:"Customize Deployment",permalink:"/doc/clarinet/guides/how-to-use-deployment-plans"},next:{title:"Clarinet Deployment Plans",permalink:"/doc/clarinet/guides/clarinet-deploy"}},o={},c=[{value:"Enable static analysis pass",id:"enable-static-analysis-pass",level:2},{value:"Options",id:"options",level:3},{value:"Annotations",id:"annotations",level:3}],u={toc:c},p="wrapper";function h(e){let{components:t,...n}=e;return(0,r.kt)(p,(0,a.Z)({},u,n,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The check-checker is a static analysis pass you can use to help find potential vulnerabilities in your contracts."),(0,r.kt)("p",null,(0,r.kt)("em",{parentName:"p"},"Topics covered in this guide"),":"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"#enable-static-analysis-pass"},"Enable static analysis pass")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"#options"},"Check checker options")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"#annotations"},"Annotations"))),(0,r.kt)("h2",{id:"enable-static-analysis-pass"},"Enable static analysis pass"),(0,r.kt)("p",null,"To enable the static analysis pass, add the following lines to your Clarinet.toml file:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-toml"},'[repl.analysis]\npasses = ["check_checker"]\n')),(0,r.kt)("p",null,"The check-checker pass analyzes your contract to identify places where untrusted inputs might be used in a potentially dangerous way.\nSince anyone can call public functions, any arguments passed to these functions should be considered untrusted.\nThis analysis pass takes the opinion that all untrusted data must be checked before being used to modify the state of a blockchain.\nModifying the state includes any operations that affect wallet balances or any data stored in your contracts."),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Actions on Stacks wallets:",(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"stx-burn?"),(0,r.kt)("li",{parentName:"ul"},"stx-transfer?"))),(0,r.kt)("li",{parentName:"ul"},"Actions on fungible tokens:",(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"ft-burn?"),(0,r.kt)("li",{parentName:"ul"},"ft-mint?"),(0,r.kt)("li",{parentName:"ul"},"ft-transfer?"))),(0,r.kt)("li",{parentName:"ul"},"Actions on non-fungible tokens:",(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"nft-burn?"),(0,r.kt)("li",{parentName:"ul"},"nft-mint?"),(0,r.kt)("li",{parentName:"ul"},"nft-transfer?"))),(0,r.kt)("li",{parentName:"ul"},"Actions on persisted data:",(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"Maps:",(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"map-delete"),(0,r.kt)("li",{parentName:"ul"},"map-insert"),(0,r.kt)("li",{parentName:"ul"},"map-set"))),(0,r.kt)("li",{parentName:"ul"},"Variables:",(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"var-set")))))),(0,r.kt)("p",null,"In addition to those operations, the check-checker is opinionated and prefers that untrusted data be checked near the source,\nmaking the code more readable and maintainable. For this reason,the check-checker also requires that arguments of private functions and the return values be checked."),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Calls to private functions"),(0,r.kt)("li",{parentName:"ul"},"Return values")),(0,r.kt)("p",null,"Finally, another opportunity for exploits appears when contracts call functions from traits. Those traits are untrusted, just like other parameters to public functions, so they must also be checked."),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Dynamic contract calls (through traits)")),(0,r.kt)("p",null,"When an untrusted input is used in one of these ways, you will see a warning like this:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"bank:27:37: warning: use of potentially unchecked data\n        (as-contract (stx-transfer? (to-uint amount) tx-sender customer))\n                                    ^~~~~~~~~~~~~~~~\nbank:21:36: note: source of untrusted input here\n(define-public (withdrawal-unsafe (amount int))\n")),(0,r.kt)("p",null,"In the case where an operation affects only the sender's wallet (e.g., calling ",(0,r.kt)("inlineCode",{parentName:"p"},"stx-transfer?")," with the sender\nset to ",(0,r.kt)("inlineCode",{parentName:"p"},"tx-sender"),"), there is no need to generate a warning because the untrusted input affects only the sender,\nwho is the source of that input. In other words, the sender should be able to safely specify parameters in an\noperation that affects only themselves. This sender is also potentially protected by post-conditions."),(0,r.kt)("p",null,"For a video walkthrough on how to check for smart contract vulnerabilities, please see the ",(0,r.kt)("a",{parentName:"p",href:"https://www.youtube.com/watch?v=v2qXFL2owC8"},"Catch Smart Contract Vulnerabilities With Clarinet's Check-Checker Feature")," video."),(0,r.kt)("h3",{id:"options"},"Options"),(0,r.kt)("p",null,"The check-checker provides various options that can be specified in ",(0,r.kt)("inlineCode",{parentName:"p"},"Clarinet.toml")," to handle common usage scenarios that\nmay reduce false positives from the analysis:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-toml"},"[repl.analysis.check_checker]\nstrict = false\ntrusted_sender = true\ntrusted_caller = true\ncallee_filter = true\n")),(0,r.kt)("p",null,"If ",(0,r.kt)("inlineCode",{parentName:"p"},"strict")," is set to ",(0,r.kt)("inlineCode",{parentName:"p"},"true"),", all other options are ignored, and the analysis proceeds with the most strict interpretation of the rules."),(0,r.kt)("p",null,"The ",(0,r.kt)("inlineCode",{parentName:"p"},"trusted_sender")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"trusted_caller")," options handle a common practice in smart contracts where there is a concept of a\ntrusted transaction sender (or transaction caller), which is treated like an admin user. Once a check has been performed\nto validate the sender (or caller), all inputs should be trusted."),(0,r.kt)("p",null,"In the example below, the ",(0,r.kt)("inlineCode",{parentName:"p"},"asserts!")," on line 3 verifies the ",(0,r.kt)("inlineCode",{parentName:"p"},"tx-sender"),". Because of that check, all inputs are trusted\n(if the ",(0,r.kt)("inlineCode",{parentName:"p"},"trusted_sender")," option is enabled):"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-clarity"},"(define-public (take (amount int) (from principal))\n    (let ((balance (- (default-to 0 (get amount (map-get? accounts {holder: from}))) amount)))\n        (asserts! (is-eq tx-sender (var-get bank-owner)) err-unauthorized)\n        (map-set accounts {holder: from} {amount: balance})\n        (stx-transfer? (to-uint amount) (as-contract tx-sender) tx-sender)\n    )\n)\n")),(0,r.kt)("p",null,"The ",(0,r.kt)("inlineCode",{parentName:"p"},"callee_filter")," option loosens the restriction on passing untrusted data to private functions. This option\nenables checks in a called function to propagate to the caller, enabling developers to\ndefine input checks in a function that can be reused."),(0,r.kt)("p",null,"In the example below, the private function ",(0,r.kt)("inlineCode",{parentName:"p"},"validate")," checks its parameter. The public function ",(0,r.kt)("inlineCode",{parentName:"p"},"save")," calls ",(0,r.kt)("inlineCode",{parentName:"p"},"validate"),",\nand when the ",(0,r.kt)("inlineCode",{parentName:"p"},"callee_filter")," option is enabled, that call to ",(0,r.kt)("inlineCode",{parentName:"p"},"validate")," will count as a check for the untrusted\ninput ",(0,r.kt)("inlineCode",{parentName:"p"},"amount")," resulting in no warnings from the check-checker."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-clarity"},"(define-public (save (amount uint))\n    (begin\n        (try! (validate amount))\n        (var-set saved amount)\n        (ok amount)\n    )\n)\n(define-private (validate (amount uint))\n    (let ((current (var-get saved)))\n        (asserts! (> amount current) err-too-low)\n        (asserts! (<= amount (* current u2)) err-too-high)\n        (ok amount)\n    )\n)\n")),(0,r.kt)("h3",{id:"annotations"},"Annotations"),(0,r.kt)("p",null,'Sometimes, there is code that the check-checker analysis cannot validate as safe. However, as a developer,\nyou know the code is safe and want to pass that information to the check-checker to turn off such false positive warnings. Check-checker supports several annotations, implemented using "magic comments" in the contract code, to handle such cases.'),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},(0,r.kt)("inlineCode",{parentName:"strong"},"#[allow(unchecked_params)]"))),(0,r.kt)("p",null,"This annotation tells the check-checker that the associated private function is allowed to receive unchecked arguments.\nThe check-checker will not generate a warning for calls to this function that pass unchecked inputs. Inside the private function,\nthe parameters are considered unchecked and could generate warnings."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-clarity"},";; #[allow(unchecked_params)]\n(define-private (my-func (amount uint))\n    ...\n)\n")),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},(0,r.kt)("inlineCode",{parentName:"strong"},"#[allow(unchecked_data)]"))),(0,r.kt)("p",null,"This annotation tells the check-checker that the following expression is allowed to use unchecked data without warnings.\nIt should be used carefully, as it will turnoff all warnings from the associated expression."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-clarity"},"(define-public (dangerous (amount uint))\n    (let ((sender tx-sender))\n        ;; #[allow(unchecked_data)]\n        (as-contract (stx-transfer? amount tx-sender sender))\n    )\n)\n")),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},(0,r.kt)("inlineCode",{parentName:"strong"},"#[filter(var1, var2)]"))),(0,r.kt)("p",null,"This annotation will tell the check-checker to consider the specified variables to be checked by the following expression.\nThis is useful for the case where your contract performs some indirect check that validates that an input is safe,\nbut there is no way for the analysis to recognize this. In place of the list of variable names in the annotation, an ",(0,r.kt)("inlineCode",{parentName:"p"},"*"),"\nmay be used to filter all inputs."),(0,r.kt)("p",null,(0,r.kt)("em",{parentName:"p"},"This is the safest and preferred way to silence warnings that you consider false positives.")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-clarity"},"(define-public (filter_one (amount uint))\n    (let ((sender tx-sender))\n        ;; #[filter(amount)]\n        (asserts! (> block-height u1000) (err u400))\n        (as-contract (stx-transfer? amount tx-sender sender))\n    )\n)\n")))}h.isMDXComponent=!0}}]);